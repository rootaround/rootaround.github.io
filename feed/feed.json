{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "root around",
  "language": "ru",
  "home_page_url": "https://rootaround.github.io/",
  "feed_url": "https://rootaround.github.io/feed/feed.json",
  "description": "",
  "author": {
    "name": "",
    "url": ""
  },
  "items": [{
      "id": "https://rootaround.github.io/posts/blog/2023-12-21/",
      "url": "https://rootaround.github.io/posts/blog/2023-12-21/",
      "title": "2023-12-21",
      "content_html": "<p><img src=\"https://rootaround.github.io/posts/img/banner.jpg\" /></p>\n",
      "date_published": "2023-12-21T12:24:04Z"
    },{
      "id": "https://rootaround.github.io/posts/tags/ash/",
      "url": "https://rootaround.github.io/posts/tags/ash/",
      "title": "",
      "content_html": "",
      "date_published": "2023-12-21T04:55:48Z"
    },{
      "id": "https://rootaround.github.io/toc/",
      "url": "https://rootaround.github.io/toc/",
      "title": "",
      "content_html": "<!-- [[2020-05-13-linux-first-shortly-about-kernel]]\n\n\n[[javascript]] -->\n",
      "date_published": "2023-12-21T04:55:48Z"
    },{
      "id": "https://rootaround.github.io/posts/wiki/roadmap/",
      "url": "https://rootaround.github.io/posts/wiki/roadmap/",
      "title": "roadmap",
      "content_html": "<h1 id=\"2022-iyul\" tabindex=\"-1\">2022 июль <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/roadmap/#2022-iyul\" aria-hidden=\"true\">#</a></h1>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /> Собрать cheatsheet по <a href=\"https://rootaround.github.io/posts/wiki/sh\">sh</a></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /> Написать про <a href=\"https://rootaround.github.io/posts/wiki/roadmap/\">linux-streams</a></li>\n</ul>\n",
      "date_published": "2022-07-27T16:15:00Z"
    },{
      "id": "https://rootaround.github.io/posts/wiki/sh/",
      "url": "https://rootaround.github.io/posts/wiki/sh/",
      "title": "sh",
      "content_html": "<p>Дефолтный shell интерпретатор в ubuntu dash, он же ash, в других дистрибутивах может по-другому, но синтаксис и опции по идее должны быть плюс, минус одинаковыми.</p>\n<p>Про ash есть серия статей по тэгу <a href=\"https://rootaround.github.io/tags/ash\">ash</a>.</p>\n<p>В этом разделе собран своего рода cheatsheet по shell.</p>\n<p>Источником для серии статей и этого раздела является документацию по <a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">dash</a>.</p>\n<p></p><div class=\"table-of-contents\"><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#rezhimy-zapuska\">Режимы запуска </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#interactive-shell\">Interactive shell </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#non-interactive-shell\">Non-interactive shell </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#login-shell\">Login shell </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#arguments\">Arguments </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#noexec-n\">noexec, -n </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#verbose-v\">verbose, -v </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#xtrace-x\">xtrace, -x </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#errexit-e\">errexit, -e </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#allexport-a\">allexport,  -a </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#command-c\">command, -c </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#noclobber-c\">noclobber, -C </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#noglob-f\">noglob, -f </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#nounset-u\">nounset, -u </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#ignoreeof-i\">ignoreeof, -I </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#interactive-i\">interactive, -i </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#login-l\">login, -l </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#monitor-m\">monitor, -m </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#stdin-s\">stdin,-s </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#operators\">Operators </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#escaping\">Escaping </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#obratnyj-slesh-backslash\"> обратный слэш — backslash </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#parnye-odinarnye-kavychki-matched-single-quotes\">парные одинарные кавычки — matched single quotes </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#parnye-dvojnye-kavychki-matched-double-qoutes\">парные двойные кавычки — matched double qoutes </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#commands\">Commands </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-shell-funkczij\"> Выполнение shell-функций </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-builtin-komand\"> Выполнение builtin-команд </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-komand-programm\"> Выполнение команд-программ </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-komand-programm-podrobnee\"> Выполнение команд-программ (подробнее) </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#magic-number\"> magic_number </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#shebang\"> shebang </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#exit-status\"> Exit status </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#complex-commands\"> Complex Commands </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#pipelines\"> Pipelines </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#spiski-lists\"> Списки - Lists </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#gruppirovka-spiskov-komand\"> Группировка списков команд </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#uslovnye-konstrukczii-i-czikly\"> Условные конструкции и циклы </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#if-then\"> if … then </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#while\"> while </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#until\"> until </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#for\"> for </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#break-continue\"> break, continue </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#case\"> case </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#functions\">Functions </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#parametry-i-peremennye\"> Параметры и переменные </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#potoki-v-funkcziyah\"> Потоки в функциях </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#redirections\">Redirections </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file\"> оператор [n]&gt; file </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file-1\"> оператор [n]&gt;| file </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file-2\"> оператор [n]&gt;&gt; file </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file-3\"> оператор [n]&lt; file </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n1-and-n2\"> оператор [n1]&gt;&amp;n2 </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#mnogostrochnye-dannye-dlya-potoka-here-document-heredoc\"> Многострочные данные для потока - here-document, heredoc </a></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#rabota-s-deskriptorami\"> Работа с дескрипторами </a></li></ul></li><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#variables\">Variables </a><ul><li><a href=\"https://rootaround.github.io/posts/wiki/sh/#environment-variables\">Environment variables </a></li></ul></li></ul></div><p></p>\n<hr />\n<h1 id=\"rezhimy-zapuska\" tabindex=\"-1\">Режимы запуска <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#rezhimy-zapuska\" aria-hidden=\"true\">#</a></h1>\n<h2 id=\"interactive-shell\" tabindex=\"-1\">Interactive shell <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#interactive-shell\" aria-hidden=\"true\">#</a></h2>\n<p>Обычно так и запускается, принудительно можно включить опцией <code>-i</code>.</p>\n<p>Ожидает команд из stdin, в stdout пишет результаты, в stderr отладку и ошибки - подробнее будет в <a href=\"https://rootaround.github.io/posts/wiki/sh/\">linux-streams</a></p>\n<h2 id=\"non-interactive-shell\" tabindex=\"-1\">Non-interactive shell <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#non-interactive-shell\" aria-hidden=\"true\">#</a></h2>\n<p>Включается при указании пути к скрипту или с аргументом <code>-c</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sh</span> ./test.sh\n\n$ <span class=\"token function\">sh</span> <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo 100500'</span></code></pre>\n<h2 id=\"login-shell\" tabindex=\"-1\">Login shell <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#login-shell\" aria-hidden=\"true\">#</a></h2>\n<p>Еще одним режимом запуска является login, включается опцией <code>-l</code> или передачей первым аргументом символа <code>-</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash <span class=\"token parameter variable\">-l</span>\n\n$ ash -</code></pre>\n<p>Работает в interactive и non-interactive режимах.</p>\n<p>Смысл режима инициализировать окружение для пользователя. В login-режиме ash ищет и выполняет shell-скрипты <code>/etc/profile</code> и <code>$HOME/.profile</code>. Если в этих файлах указать и экспортировать переменную ENV, в которой указать путь к файлу, его содержимое также будет обработано и выполнено как shell-скрипт на этапе запуска.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">ENV</span><span class=\"token operator\">=</span><span class=\"token environment constant\">$HOME</span>/.shinit<span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">export</span> ENV</code></pre>\n<p> </p>\n<hr />\n<h1 id=\"arguments\" tabindex=\"-1\">Arguments <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#arguments\" aria-hidden=\"true\">#</a></h1>\n<h2 id=\"noexec-n\" tabindex=\"-1\">noexec, <code>-n</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#noexec-n\" aria-hidden=\"true\">#</a></h2>\n<p>Проверка скрипта без выполнения команд. Работает только при выполнении файла-скрипта, но <strong>не</strong> работает при указании команд через <code>-c</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n\n$ ash test.sh\n<span class=\"token number\">123</span>\n\n$ ash <span class=\"token parameter variable\">-n</span> test.sh</code></pre>\n<p>У последней команды не будет никакого вывода, потому что указан аргумент <code>-n</code> и команды echo и exit не будет выполнены, но в случае именно ошибки синтаксиса выведется текст ошибки и ненулевой exit code.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token operator\">&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\"># '&amp;' в начале это ошибка в shell-скрипте</span>\n\n$ ash <span class=\"token parameter variable\">-n</span> test.sh\n./test.sh: line <span class=\"token number\">1</span>: syntax error: unexpected <span class=\"token string\">\"&amp;\"</span></code></pre>\n<p>Конечно этот режим не проверяет наличие самих команд, но для проверки синтаксиса удобно.</p>\n<h2 id=\"verbose-v\" tabindex=\"-1\">verbose, <code>-v</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#verbose-v\" aria-hidden=\"true\">#</a></h2>\n<p>В stderr будет записано все что ash читает в процессе работы.</p>\n<p>Например, в login-режиме (про него далее) читается файл <code>$HOME/.profile</code> и выполняются команды из него – с опцией <code>-v</code> все содержимое <code>.profile</code> будет записано в stderr для отладки.</p>\n<h2 id=\"xtrace-x\" tabindex=\"-1\">xtrace, <code>-x</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#xtrace-x\" aria-hidden=\"true\">#</a></h2>\n<p>С этим аргументом каждая выполняемая команда будет записано в stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n\n$ ash <span class=\"token parameter variable\">-x</span> test.sh\n+ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span>\n<span class=\"token number\">123</span>\n+ <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span></code></pre>\n<p>Вообще все опции включатся через <code>-</code> , а выключаются через <code>+</code> <em>// кажется что нелогично и должно быть наоборот</em></p>\n<p>В интерактивном режиме тоже можно включать опции с помощью builtin-команды set</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">set</span> <span class=\"token parameter variable\">-x</span>\n\n<span class=\"token comment\"># xtrace ВКЛючен</span>\n\n$ <span class=\"token builtin class-name\">set</span> +x\n\n<span class=\"token comment\"># xtrace ВЫКЛючен</span></code></pre>\n<h2 id=\"errexit-e\" tabindex=\"-1\">errexit, <code>-e</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#errexit-e\" aria-hidden=\"true\">#</a></h2>\n<p>С <code>-e</code> все непротестированные команды (без проверки exit-кода через <code>if</code>, <code>elif</code>) будут приводить к завершению скрипта.</p>\n<p>Для примера рассмотрим скрипт с листингом несуществующей директории.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">ls</span> /none<span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n\n$ ash test.sh\nls: /none: No such <span class=\"token function\">file</span> or directory\ngood\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">0</span></code></pre>\n<p>При обычном запуске команды <code>ls</code> и <code>echo</code> выполняются независимо друг от друга и <code>echo</code> будет выполнено после <code>ls</code> <em>// конечно в данном случае нужно использовать <code>&amp;&amp;</code>, но об этом в следующих статьях</em></p>\n<p>С аргументом <code>-e</code> выход из скрипта произойдет после <code>ls</code> и скрипт завершится с ненулевым exit-кодом.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash <span class=\"token parameter variable\">-e</span> test.sh\nls: /none: No such <span class=\"token function\">file</span> or directory\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">1</span></code></pre>\n<p>Еще один полезный момент — передача параметров при запуске скрипта. Все аргументы после указания пути к скрипту считаются позиционными аргументами и могут быть почитаны в скрипте из переменных $1, $2</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$11</span>\n\n$ ash test.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">6</span> <span class=\"token number\">7</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">10</span> <span class=\"token number\">11</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">11</span></code></pre>\n<p>Отдельно стоит отметить $0 - это переменная содержит путь к скрипту</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$0</span>\n\n$ ash ./test.sh\n./test.sh</code></pre>\n<h2 id=\"allexport-a\" tabindex=\"-1\">allexport,  <code>-a</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#allexport-a\" aria-hidden=\"true\">#</a></h2>\n<p>Экспорт env-переменных <em>// не увидел разницы с обычным режимом, все назначенные переменные окружения и так видны внутри shell при запуске</em></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">env</span> <span class=\"token parameter variable\">-i</span> <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span> ash <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo $TEST'</span>\n<span class=\"token number\">100</span>\n\n$ <span class=\"token function\">env</span> <span class=\"token parameter variable\">-i</span> <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span> ash <span class=\"token parameter variable\">-a</span> <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo $TEST'</span>\n<span class=\"token number\">100</span></code></pre>\n<h2 id=\"command-c\" tabindex=\"-1\">command, <code>-c</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#command-c\" aria-hidden=\"true\">#</a></h2>\n<p>Режим выполнения команд, выполняет команды указанные после аргумента</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo 100500'</span>\n<span class=\"token number\">100500</span></code></pre>\n<h2 id=\"noclobber-c\" tabindex=\"-1\">noclobber, <code>-C</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#noclobber-c\" aria-hidden=\"true\">#</a></h2>\n<p>тут речь про оператор <code>&gt;</code> при перенаправление потока в файл, по умолчанию этот оператор создает или перезаписывает содержимое файла, аргумент <code>-C</code> меняет это поведение — если файл уже существует, произойдет ошибка.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># скрипт записывает значение первого аргумента в файл tmp.txt</span>\n$ <span class=\"token function\">cat</span> ./test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$1</span> <span class=\"token operator\">></span> tmp.txt\n\n<span class=\"token comment\"># выполняем</span>\n$ ash ./test.sh <span class=\"token number\">100</span>\n\n<span class=\"token comment\"># в файл записано 100</span>\n$ <span class=\"token function\">cat</span> tmp.txt\n<span class=\"token number\">100</span>\n\n<span class=\"token comment\"># выполняем еще раз</span>\n$ ash ./test.txt <span class=\"token number\">101</span>\n\n<span class=\"token comment\"># файл перезаписан со значением 101</span>\n$ <span class=\"token function\">cat</span> tmp.txt\n<span class=\"token number\">101</span>\n\n<span class=\"token comment\"># выполняем c аргументом -C - получаем ошибку</span>\n$ ash <span class=\"token parameter variable\">-C</span> ./test.txt <span class=\"token number\">102</span>\ntest.sh: line <span class=\"token number\">1</span>: can't create test.txt: File exists</code></pre>\n<h2 id=\"noglob-f\" tabindex=\"-1\">noglob, <code>-f</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#noglob-f\" aria-hidden=\"true\">#</a></h2>\n<p>В шеллах существует прекрасная штука - file globbing - это возможность указывать путь к файлам не полностью, а, например, через wildcard — <code>cat *.txt</code> — вывести на экран все файлы с расширением txt.</p>\n<p>Так вот опция <code>-f</code> отключает file globbing для выполняемого скрипта.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token comment\"># this is script</span>\n<span class=\"token function\">cat</span> *.sh\n\n<span class=\"token comment\"># выводит все файлы с расширением sh</span>\n$ ash test.sh\n<span class=\"token comment\"># this is script</span>\n<span class=\"token function\">cat</span> *.sh\n\n<span class=\"token function\">file</span> globbing отключен - *.sh интерпретируется как имя файла\n$ ash <span class=\"token parameter variable\">-f</span> test.sh\ncat: can<span class=\"token string\">'t open '</span>*.sh': No such <span class=\"token function\">file</span> or directory</code></pre>\n<h2 id=\"nounset-u\" tabindex=\"-1\">nounset, <code>-u</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#nounset-u\" aria-hidden=\"true\">#</a></h2>\n<p>Завершать скрипт с ошибкой если происходит обращение к переменной, которая не определена.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$SOME</span>\n\n<span class=\"token comment\"># скрипт успешно выполнен, хотя переменная SOME не определена</span>\n$ ash test.sh\n\n<span class=\"token comment\"># с аргументом -u присходит ошибка</span>\n$ ash <span class=\"token parameter variable\">-u</span> test.sh\ntest.sh: line <span class=\"token number\">1</span>: SOME: parameter not <span class=\"token builtin class-name\">set</span></code></pre>\n<h2 id=\"ignoreeof-i\" tabindex=\"-1\">ignoreeof, <code>-I</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#ignoreeof-i\" aria-hidden=\"true\">#</a></h2>\n<p>Игнорирует EOF (символы конца строки) из stdin</p>\n<p><em>// Пока не очень понятно зачем это нужно, но работает так</em></p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># echo передает EOF (/n) после строки и скрипт выводит содержимое файла скриптов</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'cat *.sh'</span> <span class=\"token operator\">|</span> ash\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$SOME</span>\n\n<span class=\"token comment\"># с -I конец строки игнорируется и будет ошибка</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'cat *.sh'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-I</span>\nUse <span class=\"token string\">\"exit\"</span> to leave shell.\n\nUse <span class=\"token string\">\"exit\"</span> to leave shell.\n\n<span class=\"token punctuation\">..</span>.</code></pre>\n<h2 id=\"interactive-i\" tabindex=\"-1\">interactive, <code>-i</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#interactive-i\" aria-hidden=\"true\">#</a></h2>\n<p>принудительно включается интерактивный режим</p>\n<h2 id=\"login-l\" tabindex=\"-1\">login, <code>-l</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#login-l\" aria-hidden=\"true\">#</a></h2>\n<p>Включает login-режим</p>\n<h2 id=\"monitor-m\" tabindex=\"-1\">monitor, <code>-m</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#monitor-m\" aria-hidden=\"true\">#</a></h2>\n<p>включает job control, автоматически включается в интерактивном режиме, видимо позволяет включать работу с jobs в скриптах <em>// рассмотрим позже, но уже интересно — можно запустить задачу фоном в скрипте, а потом проконтролировать ее и завершить скрипт</em></p>\n<h2 id=\"stdin-s\" tabindex=\"-1\">stdin,<code>-s</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#stdin-s\" aria-hidden=\"true\">#</a></h2>\n<p>читать скрипт из stdin. Если не указан путь к скрипту, то включено.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span>\n\n<span class=\"token comment\"># идентично c -s</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-s</span>\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span>\n\n<span class=\"token comment\"># но не работает если указан скрипт</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-s</span> test.sh\n<span class=\"token comment\"># test script commands</span>\n\n<span class=\"token comment\"># при этом выполняются обе команды с -c и -s</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'date'</span>\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span>\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span></code></pre>\n<p> </p>\n<hr />\n<h1 id=\"operators\" tabindex=\"-1\">Operators <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operators\" aria-hidden=\"true\">#</a></h1>\n<p>ash читает скрипт построчно, разбивает его на слова по пробелам и табам.</p>\n<p>Некоторые последовательности символов определяются как операторы.</p>\n<p>Операторы бывают двух видов:</p>\n<ol>\n<li>Control operators — для объединения команд в группы, цепочки-пайпланы и условия</li>\n</ol>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">&amp;</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">|</span> <span class=\"token operator\">||</span> <span class=\"token operator\">&lt;</span>newline<span class=\"token operator\">></span></code></pre>\n<ol start=\"2\">\n<li>Redirection operators — для перенаправления потоков между командами и не только</li>\n</ol>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">&lt;</span> <span class=\"token operator\">></span> <span class=\"token operator\">>|</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">>></span> <span class=\"token operator\">&lt;&amp;</span> <span class=\"token operator\">>&amp;</span> <span class=\"token operator\">&lt;&lt;-</span> <span class=\"token operator\">&lt;></span></code></pre>\n<p> </p>\n<hr />\n<h1 id=\"escaping\" tabindex=\"-1\">Escaping <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#escaping\" aria-hidden=\"true\">#</a></h1>\n<p>Стандартной проблемой в шеллах и в языках программирования является использование специальных символов (и последовательностей) как обычных символов – это называют экранированием (escape special chars). В ash экранирование спец символов можно сделать 3 способами:</p>\n<ul>\n<li>обратный слэш — backslash</li>\n<li>парные одинарные кавычки — matched single quotes</li>\n<li>парные двойные кавычки — matched double qoutes</li>\n</ul>\n<h2 id=\"obratnyj-slesh-backslash\" tabindex=\"-1\"><a id=\"backslash\" href=\"https://rootaround.github.io/posts/wiki/sh/#backslash\"></a> обратный слэш — backslash <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#obratnyj-slesh-backslash\" aria-hidden=\"true\">#</a></h2>\n<p>Backslash перед спец символом делает его обычным символом</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># команда ничего не выведет,</span>\n<span class=\"token comment\"># потому что точка с запятой интеретируется как разделитель команд</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># выведется точка с запятой, как обычный символ</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">;</span></code></pre>\n<p>Кроме этого backslash перед символом конца строки (переводом строки) интерпретируется как продолжение строки</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">\\</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">\\</span>\n<span class=\"token number\">3</span>\n<span class=\"token number\">123</span></code></pre>\n<h2 id=\"parnye-odinarnye-kavychki-matched-single-quotes\" tabindex=\"-1\">парные одинарные кавычки — matched single quotes <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#parnye-odinarnye-kavychki-matched-single-quotes\" aria-hidden=\"true\">#</a></h2>\n<p>Все что внутри одинарных кавычек, кроме одинарных кавычек, считается обычным символом</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'&amp;;|>>'</span>\n<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">;</span><span class=\"token operator\">|</span><span class=\"token operator\">>></span></code></pre>\n<p>Одинарные кавычки при необходимости можно вывести отдельно с помощью <a href=\"https://rootaround.github.io/posts/wiki/sh/#backslash\">backslash</a></p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># последняя кавычка экранирована с помощью backslash</span>\n<span class=\"token comment\"># и считается обычным символом</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'&amp;|$'</span><span class=\"token punctuation\">\\</span>'\n<span class=\"token operator\">&amp;</span><span class=\"token operator\">|</span><span class=\"token string\">$'\n\n$ echo '</span><span class=\"token environment constant\">$PATH</span>'\n<span class=\"token environment constant\">$PATH</span></code></pre>\n<h2 id=\"parnye-dvojnye-kavychki-matched-double-qoutes\" tabindex=\"-1\">парные двойные кавычки — matched double qoutes <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#parnye-dvojnye-kavychki-matched-double-qoutes\" aria-hidden=\"true\">#</a></h2>\n<p>С двойными кавычками все немного сложнеe.</p>\n<p>Все символы внутри двойных кавычек считаются обычными, за исключением символов:</p>\n<ul>\n<li>знака доллара (dollarsign) - <code>$</code>,</li>\n<li>обратной кавычки (backquote) - <code>`</code></li>\n<li>и обратного слэша (backslash) - <code>\\</code></li>\n</ul>\n<p>backslash внутри двойных кавычек позволяет экранировать только символы: <code>$ ` &quot; \\ \\ </code>  <code>&lt;newline&gt;</code></p>\n<p>Кратко рассмотрим зачем вообще нужны эти символы – дальше они будут разобраны подробнее.</p>\n<h3 id=\"dollarsign\" tabindex=\"-1\"><code>$</code> - dollarsign <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#dollarsign\" aria-hidden=\"true\">#</a></h3>\n<p>с помощью <code>$</code> можно использовать shell-переменные вообще без кавычек</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/sbin:/usr/sbin:/bin:/usr/bin\n\n<span class=\"token comment\"># аналогично $ работает в двойных кавычках</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token environment constant\">$PATH</span>\"</span>\n/sbin:/usr/sbin:/bin:/usr/bin</code></pre>\n<h3 id=\"backquote\" tabindex=\"-1\"><code>`</code> - backquote <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#backquote\" aria-hidden=\"true\">#</a></h3>\n<p>команда, заключенная в обратные кавычки, выполняется и output команды подставляется вместо обратных кавычек. Работает и без двойных кавычек.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">`</span></span>\n/home/ubuntu\n\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"current directory is <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">`</span></span>\"</span>\ncurrent directory is /home/ubuntu</code></pre>\n<h3 id=\"backslash\" tabindex=\"-1\"><code>\\</code> - backslash <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#backslash\" aria-hidden=\"true\">#</a></h3>\n<p>работает как и раньше, экранирует символы: <code>$ ` &quot; \\ </code> и backslash перед переводом строки считается продолжением строки без переноса</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token environment constant\">$PWD</span> = \\\n<span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token environment constant\">$PWD</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>\"</span>\n<span class=\"token environment constant\">$PWD</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"/home/ubuntu\"</span></code></pre>\n<h3 id=\"kombinirovanie-raznyh-kavychek-dlya-komand-i-argumentov\" tabindex=\"-1\"><a id=\"combine-quotes\" href=\"https://rootaround.github.io/posts/wiki/sh/#combine-quotes\"></a> Комбинирование разных кавычек для команд и аргументов <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#kombinirovanie-raznyh-kavychek-dlya-komand-i-argumentov\" aria-hidden=\"true\">#</a></h3>\n<p>Все способы формирования можно комбинировать: использовать поочерердно разные кавычки, переменные:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> my<span class=\"token string\">' path is '</span><span class=\"token string\">\" = \"</span><span class=\"token environment constant\">$PWD</span><span class=\"token string\">\"\"</span>\nmy path is  <span class=\"token operator\">=</span> /home/ubuntu</code></pre>\n<p>Главное чтобы в рамках одного аргумента строки соединялись без пробелов, иначе после пробела shell будет считать строку уже другим аргументом.</p>\n<p> </p>\n<hr />\n<h1 id=\"commands\" tabindex=\"-1\">Commands <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#commands\" aria-hidden=\"true\">#</a></h1>\n<p>Вот мы и подобрались к сути, ведь shell нужен как раз для выполнения команд.</p>\n<p>Если при обработке строки скрипта первое слово не является зарезервирванным, то ash начинает обработку этой строки как команды.</p>\n<!--\nКоманды могут быть простыми — вызов одной команды, или сложными конструкциями из нескольких связанных команд с условиями или без. Начнем по порядку с простых команд.\n\nДля примера рассмотрим команду `env`, которая выводит текущие переменные окружения (environment variables).\n\n```bash\n$ env\nSHLVL=1\nPATH=/sbin:/usr/sbin:/bin:/usr/bin\nPWD=/home/ubuntu\n```\n\nКоманда вывела несколько переменных окружнения:\n\n- `SHLVL` - текущий уровень “вложенности” шеллов, если в этом шелл запустить еще раз команду ash - SHLVL будет равен 2, а внутри этого шелла запустить еще один, то в нем будет SHLVL=3 и так далее\n- `PATH` - пути разделенные двоеточиями где нужно искать команды — об этом поговорим чуть дальше\n- `PWD` - текущая директория, в которой в данный момент мы находимся, эта env-переменная менятся при переходе между директориями командой `cd`\n-->\n<p>Cуществуют 3 типа команд: shell-функции, buildin-команды и программы. При выполнении осуществляется поиск команды именно в таком порядке.</p>\n<h2 id=\"vypolnenie-shell-funkczij\" tabindex=\"-1\"><a id=\"command-types-shell-functions\" href=\"https://rootaround.github.io/posts/wiki/sh/#command-types-shell-functions\"></a> Выполнение shell-функций <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-shell-funkczij\" aria-hidden=\"true\">#</a></h2>\n<p>Все аргументы переданные с вызовом функции, передаются в функцию. Все environment-переменные также доступны внутри функции. Сама функция выполняется в текущем шелле.\nСейчас важно то что функции также как можно использовать также как и команды-программы и builtin-функции, то есть создавать комбинации из функций и команд.</p>\n<p>Функции рассмотрим в следующих статьях. Сейчас небольшой пример использования</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ hello <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span>\"</span>\n<span class=\"token comment\"># stdout можно перенаправить</span>\n$ hello Kenneth <span class=\"token operator\">></span> ./tmp.txt\n<span class=\"token comment\"># или использовать в пайплайнах</span>\n<span class=\"token comment\">#  - пайплайны разберем в этой статье</span>\n$ hello Kenneth <span class=\"token operator\">|</span> <span class=\"token function\">cat</span>\nhello, Kenneth</code></pre>\n<h2 id=\"vypolnenie-builtin-komand\" tabindex=\"-1\"><a id=\"command-types-builtin\" href=\"https://rootaround.github.io/posts/wiki/sh/#command-types-builtin\"></a> Выполнение builtin-команд <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-builtin-komand\" aria-hidden=\"true\">#</a></h2>\n<p>builtin-команды выполняются внутри текущего shell, без запуска отдельного процесса.\nbuiltin-команды в ash также разберем отдельной статьей, их достаточно много, но в общем некоторые общие команды такие как <code>echo</code>, <code>ls</code> и другие могут быть встроены в shell.</p>\n<h2 id=\"vypolnenie-komand-programm\" tabindex=\"-1\"><a id=\"command-types-programs\" href=\"https://rootaround.github.io/posts/wiki/sh/#command-types-programs\"></a> Выполнение команд-программ <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-komand-programm\" aria-hidden=\"true\">#</a></h2>\n<p>Если имя команды не является shell-функцией или builtin-командой, значит это программа в файловой системе и ее нужно найти и выполнить.</p>\n<p>Если имя команды содержит слэш <code>/</code>, то команда сразу выполняется без поиска в файловой системе – имя команды используется как путь к программе</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ /usr/bin/htop\n<span class=\"token comment\"># команда запуститься сразу</span></code></pre>\n<p>Если слэшей в имени команды нет, то происходит поиск файла программы по имени в директориях из environment-переменной PATH.</p>\n<p>В переменной PATH содержится список директорий разделенных двоеточием <code>:</code>, конечно же переменную PATH можно изменить, установить свой список директорий или дополнить существующий.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/sbin:/usr/sbin:/bin:/usr/bin\n\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token environment constant\">$PATH</span>:/home/ubuntu/bin\n\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/sbin:/usr/sbin:/bin:/usr/bin:/home/ubuntu/bin</code></pre>\n<p>Текущая директория (PWD) тоже может содержаться в PATH, для этого нужно указать пустую строку между двоеточиями или в конце</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># в конце строки</span>\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/bin:\n\n<span class=\"token comment\"># пустая директория</span>\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/bin::\n\n<span class=\"token comment\"># в начале строки</span>\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>:/sbin:/bin</code></pre>\n<p>Для выполнения будет использована первая найденная команда, то есть порядок директорий важен.</p>\n<p>Если команда не существует ни в одной директории, получим ошибку not found</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ noop\n/usr/bin/ash: noop: not found</code></pre>\n<h2 id=\"vypolnenie-komand-programm-podrobnee\" tabindex=\"-1\"><a id=\"command-exec\" href=\"https://rootaround.github.io/posts/wiki/sh/#command-exec\"></a> Выполнение команд-программ (подробнее) <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#vypolnenie-komand-programm-podrobnee\" aria-hidden=\"true\">#</a></h2>\n<p>Когда команда найдена начинается ее выполнение и тут снова возможно несколько сценариев:</p>\n<h2 id=\"magic-number\" tabindex=\"-1\"><a id=\"command-exec-magic-number\" href=\"https://rootaround.github.io/posts/wiki/sh/#command-exec-magic-number\"></a> magic_number <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#magic-number\" aria-hidden=\"true\">#</a></h2>\n<p>исполняемый файл-программа начинается с magic number. Тут имеется ввиду ELF-заголовок по которому определяется что программа может выполняться и дальше при выполнении происходит чтение из этого файла используя ELF-формат.</p>\n<p>В этом случае создается новый процесс, которому переданы все аргументы команды и переменные окружения.</p>\n<h2 id=\"shebang\" tabindex=\"-1\"><a id=\"command-exec-shebang\" href=\"https://rootaround.github.io/posts/wiki/sh/#command-exec-shebang\"></a> shebang <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#shebang\" aria-hidden=\"true\">#</a></h2>\n<p>Если программа не имеет ELF-заголовка, но начинается с <code>#!</code> программа выполняется как отдельный shell. Причем после <code>#!</code> указывается интрепретатор и один аргумент</p>\n<p>Ситаксис</p>\n<pre><code>#!interprer [optional-arg]\n</code></pre>\n<p>Пример</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/usr/bin/ash</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span></code></pre>\n<p>Скрипт выше будет выполнен интерпертатором ash. Кроме shell таком образом могут выполняться программы на интерпретируемых языках программирования, например, python или php</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/usr/bin/python</span>\nprint<span class=\"token punctuation\">(</span><span class=\"token string\">'123'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Для того чтобы выполнить скрипт как программу нужно чтобы для файла был установлен атрибут eXecutable</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">chmod</span> +x ./test.sh\n$ ./test.sh\n<span class=\"token number\">123</span></code></pre>\n<h2 id=\"exit-status\" tabindex=\"-1\"><a id=\"exit-status\" href=\"https://rootaround.github.io/posts/wiki/sh/#exit-status\"></a> Exit status <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#exit-status\" aria-hidden=\"true\">#</a></h2>\n<p>В Linux каждый процесс завершается с определенным числовым статусом, exit-статусом или exit-кодом.</p>\n<p>Если exit-код равен 0 — программа выполнена успешно, другие значения означают ошибку.\nУ каждой команды свой список exit-кодов и их значение можно посмотреть в документации (man) команды.</p>\n<p>Builtin-команды и shell-функции также возвращают exit-коды.</p>\n<p>Забегая немного вперед - exit-код последней выполненной команды можно посмотреть с помощью специальной shell-переменной <code>$?</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">env</span>\n<span class=\"token comment\"># ...</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">0</span></code></pre>\n<p>В случае списков команд итоговым будет exit-код последней команды.</p>\n<p> </p>\n<hr />\n<h1 id=\"complex-commands\" tabindex=\"-1\"><a id=\"complex-commands\" href=\"https://rootaround.github.io/posts/wiki/sh/#complex-commands\"></a> Complex Commands <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#complex-commands\" aria-hidden=\"true\">#</a></h1>\n<p>Все предыдущие разделы были необходимой подготовкой к пониманию более сложных конструкций из команд.</p>\n<p>Итак команды могут быть одним из следующих:</p>\n<ul>\n<li>простой командой (simple command)</li>\n<li>пайплайном (pipeline)</li>\n<li>списком команд (list)</li>\n<li>составной командой (compound command)</li>\n<li>определением функции (function definition)</li>\n</ul>\n<h2 id=\"pipelines\" tabindex=\"-1\"><a id=\"complex-commands-pipelines\" href=\"https://rootaround.github.io/posts/wiki/sh/#complex-commands-pipelines\"></a> Pipelines <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#pipelines\" aria-hidden=\"true\">#</a></h2>\n<p>Pipeline - последовательность команд разделенных управляющим оператором <code>|</code>.</p>\n<p>Stdout каждой команды перенаправляется в stdin следующей команды, а для последней команды stdout работает как обычно. Как итоговый exit-код используется exit-код последней команды.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> abc <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span>\na</code></pre>\n<p>В примере выше stdout команды <code>echo abc</code> передается в stdin команды <code>head</code>, которая берет из своего stdin только один символ.</p>\n<p>Для примера с exit-кодом не будем передавать значение аргумента <code>-c</code>, в этом случае команда <code>head</code> завершается с ошибкой</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> abc <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ... сообщение об ошибке</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">1</span>  <span class=\"token comment\"># &lt;&lt;&lt; команда завершилась с ошибкой</span></code></pre>\n<p>Exit-код пайплайна можно инвертировать, если добавить перед пайплайном восклицательный знак <code>!</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token operator\">!</span> <span class=\"token builtin class-name\">echo</span> abc <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ... сообщение об ошибке</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">0</span></code></pre>\n<p>Для каждой команды можно использовать операторы перенаправления. Для примера возьмем вывод команды <code>head -c</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">|</span> <span class=\"token function\">cat</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<p><code>head -c</code> передает stdout команде <code>cat</code>, а уже stdout команды <code>cat</code> выводится в терминал</p>\n<p>Если перенаправить результат cat в /dev/null …</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">|</span> <span class=\"token function\">cat</span> <span class=\"token operator\">></span> /dev/null\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<p>… то ничего не поменяется, потому что текст ошибки выводится в stderr-поток, тут мы можем использовать перенаправление — перенаправляем stderr в stdout — в итоге и stderr и stdout команды <code>head</code> попадают в stdin команды <code>cat</code>, а потом в /dev/null</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span> <span class=\"token operator\">|</span> <span class=\"token function\">cat</span> <span class=\"token operator\">></span> /dev/null</code></pre>\n<h2 id=\"spiski-lists\" tabindex=\"-1\"><a id=\"lists\" href=\"https://rootaround.github.io/posts/wiki/sh/#lists\"></a> Списки - Lists <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#spiski-lists\" aria-hidden=\"true\">#</a></h2>\n<p>Для последовательного выполнения команд без перенаправления потоков существуют списки команд.</p>\n<h3 id=\"simple-list\" tabindex=\"-1\"><a id=\"simple-lists\" href=\"https://rootaround.github.io/posts/wiki/sh/#simple-lists\"></a> Simple List - <code>;</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#simple-list\" aria-hidden=\"true\">#</a></h3>\n<p>Самы простой вариант составить список без связи команд это использовать между командами <code>;</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Команды будут выполнены последовательно одна за другой в указанном порядке, при этом даже если первая команда завершится с ненулевым exit-кодом, остальные все равно будут выполнены.</p>\n<h3 id=\"and-list-and-and\" tabindex=\"-1\"><a id=\"and-lists\" href=\"https://rootaround.github.io/posts/wiki/sh/#and-lists\"></a> AND-List - <code>&amp;&amp;</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#and-list-and-and\" aria-hidden=\"true\">#</a></h3>\n<p>Для того чтобы команды выполнялись только в случае успешного завершения предыдущей команды используют оператор <code>&amp;&amp;</code>.</p>\n<p>В этом случае следующая команда будет выполнена только если предыдущая завершилась с exit-кодом равным 0.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># есть текстовый файл abc.txt, в котором содержатся 3 символа 'abc'</span>\n$ <span class=\"token function\">cat</span> abc.txt\nabc\n\n<span class=\"token comment\"># составляем список команд команд:</span>\n<span class=\"token comment\"># - head читает один символ из файла</span>\n<span class=\"token comment\"># - echo выводит '- first char in file'</span>\n<span class=\"token comment\">#   если предыдущая команда завершилась успешно</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">' - first char in file'</span>\na - first char <span class=\"token keyword\">in</span> <span class=\"token function\">file</span>\n\n<span class=\"token comment\"># head выполнилась успешно и затем выполнилась команда echo</span>\n\n<span class=\"token comment\"># если убрать число символов в команде head - возникнет ошибка -</span>\n<span class=\"token comment\"># head завершится с exit-кодом 1 и echo не будет выполнено</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">' - first char in file'</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<h3 id=\"or-list\" tabindex=\"-1\"><a id=\"or-lists\" href=\"https://rootaround.github.io/posts/wiki/sh/#or-lists\"></a> OR-List - <code>||</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#or-list\" aria-hidden=\"true\">#</a></h3>\n<p>В OR-List команда следующая за оператором <code>||</code> выполняется только если exit-код предыдущей команды больше 0.</p>\n<p>Возьмем последнюю команду из предыдущего примера и немного изменим</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># убираем значение аргумента -с</span>\n<span class=\"token comment\"># меняем &amp;&amp; на ||</span>\n<span class=\"token comment\"># меняем текст сообщения</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'it is failed'</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span>\nit is failed\n\n<span class=\"token comment\"># echo выполнилось потому что exit-код первой команды больше 0</span>\n\n<span class=\"token comment\"># если исправить первую команду - echo перестанет выполняться</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'it is failed'</span>\na</code></pre>\n<h2 id=\"gruppirovka-spiskov-komand\" tabindex=\"-1\"><a id=\"grouping\" href=\"https://rootaround.github.io/posts/wiki/sh/#grouping\"></a> Группировка списков команд <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#gruppirovka-spiskov-komand\" aria-hidden=\"true\">#</a></h2>\n<p>Команды могут быть сгруппированы двумя способами:</p>\n<h3 id=\"pervyj-ispolzuya-kruglye-skobki\" tabindex=\"-1\"><a id=\"grouping-parentheses\" href=\"https://rootaround.github.io/posts/wiki/sh/#grouping-parentheses\"></a> Первый - используя круглые скобки <code>()</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#pervyj-ispolzuya-kruglye-skobki\" aria-hidden=\"true\">#</a></h3>\n<p>В этом случае команды будут выполнены в отдельном shell и команды не будут влиять на текущий shell</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token punctuation\">(</span>echo <span class=\"token string\">'abc'</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\na\n\n$ <span class=\"token punctuation\">(</span>export <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># переменная TEST не появится в текущем shell</span></code></pre>\n<h3 id=\"vtoroj-sposob-figurnye-skobki\" tabindex=\"-1\"><a id=\"grouping-curly\" href=\"https://rootaround.github.io/posts/wiki/sh/#grouping-curly\"></a> Второй способ - фигурные скобки - <code>{}</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#vtoroj-sposob-figurnye-skobki\" aria-hidden=\"true\">#</a></h3>\n<p>Этот способ также как и первый позволяет сгруппировать stdout списка команд, как будто это одна команда, но команды выполняются в текущем shell.</p>\n<p>Первое обязательное условие этого способа - это наличие пробелов после первой и перед второй фигурными скобок.\nВторым обязательным условием является наличие точки с запятой <code>;</code> перед второй, завершающей скобкой <code>}</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">2</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token comment\"># также можно использовать другие списки, пайплайны</span>\n$ <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'abc'</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\na</code></pre>\n<p> </p>\n<hr />\n<h1 id=\"uslovnye-konstrukczii-i-czikly\" tabindex=\"-1\"><a id=\"conditions-and-loops\" href=\"https://rootaround.github.io/posts/wiki/sh/#conditions-and-loops\"></a> Условные конструкции и циклы <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#uslovnye-konstrukczii-i-czikly\" aria-hidden=\"true\">#</a></h1>\n<p>С этого момента простое выполнение команд начинает превращаться в shell-программирование 😃</p>\n<h2 id=\"if-then\" tabindex=\"-1\"><a id=\"if\" href=\"https://rootaround.github.io/posts/wiki/sh/#if\"></a> if … then <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#if-then\" aria-hidden=\"true\">#</a></h2>\n<p>Синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> list\n<span class=\"token keyword\">then</span> list\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">elif</span> list\n<span class=\"token keyword\">then</span>    list <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">..</span>.\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">else</span> list <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>Если list в <code>if</code> завершается с exit-кодом 0 - выполняется первый <code>then list</code>, а если exit-код больше 0 и есть <code>else list</code> - то будет выполнен он, аналогично для <code>elif .. then</code>.</p>\n<p>Все что после if, then, else, elif является просто списками команд.</p>\n<p>Единственным условием является разделение списка команд от служебных слов с помощью переноса строки, либо точкой с запятой <code>;</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">fi</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n\n<span class=\"token comment\"># то же самое в одну строку</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">fi</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n\n<span class=\"token comment\"># чуть более сложно выглядящий пример</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">fi</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">3</span>\n\n<span class=\"token comment\"># первый список команд завершается с exit-кодом больше 0</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token function\">ls</span> /nowhere <span class=\"token operator\">></span>/dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">else</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'bad'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">fi</span>\nbad\n<span class=\"token comment\"># выполнился else</span></code></pre>\n<p>В примерах мы видим stdout всех выполняющихся команд. Если значения stdout или stderr не нужны - их нужно перенаправлять в файлы или в /dev/null.</p>\n<p>После описания синтаксиса и примеров может возникнуть вопрос про условия в квадратных скобках</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$TEST</span> <span class=\"token operator\">==</span> <span class=\"token string\">'100'</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n<span class=\"token keyword\">else</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'bad'</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>Разве квадратные скобки не являются частью синтаксиса?</p>\n<p>Нет, не являются. И это одна из “магических” штук, которые с ходу кажутся простыми, но в итоге могут работать не так как ожидаешь.</p>\n<p>Оказывается открывающяя скобка <code>[</code> это команда <code>test</code>.</p>\n<p>Документация по <code>man [</code> и <code>man test</code> будет содержать одинаковую информацию.</p>\n<p>Если поискать такую команду с помощью <code>which</code> (which определяет где хранится команда на файловой системе используя PATH)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">which</span> <span class=\"token punctuation\">[</span>\n/usr/bin/<span class=\"token punctuation\">[</span></code></pre>\n<p>Закрывающая скобка <code>]</code> является обязательным завершающим аргументом для команды <code>[</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token punctuation\">[</span>\nash: missing <span class=\"token punctuation\">]</span></code></pre>\n<p>Конкретно в случае ash команды <code>[</code>, <code>test</code> и некоторые другие являются builtin-командами, мы разберем их через пару статей этой серии.</p>\n<p>Теперь <code>if</code> конструкция с квадратными скобками …</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$TEST</span> <span class=\"token operator\">==</span> <span class=\"token string\">'100'</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>… просто преобразуется в список из одной команды</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> <span class=\"token variable\">$TEST</span> <span class=\"token operator\">==</span> <span class=\"token string\">'100'</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>и точка с запятой в конце нужна чтобы разделить аргументы команды <code>test</code> от служебного слова <code>then</code></p>\n<h2 id=\"while\" tabindex=\"-1\"><a id=\"while\" href=\"https://rootaround.github.io/posts/wiki/sh/#while\"></a> while <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#while\" aria-hidden=\"true\">#</a></h2>\n<p>C циклом <code>while</code> все еще проще чем <code>if</code></p>\n<p>Синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> list\n<span class=\"token keyword\">do</span> list\n<span class=\"token keyword\">done</span></code></pre>\n<p>Пока список команд после <code>while</code> завершается с exit-code равным 0 выполняется список команд после <code>do</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span>.txt\n$ <span class=\"token keyword\">while</span> <span class=\"token function\">cat</span> <span class=\"token number\">1</span>.txt <span class=\"token operator\">></span>/dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'has file'</span> <span class=\"token punctuation\">;</span> <span class=\"token function\">rm</span> <span class=\"token number\">1</span>.txt\n<span class=\"token keyword\">done</span>\nhas <span class=\"token function\">file</span>\n\n<span class=\"token comment\"># has file - выводится один раз и после этого следует выход из цикла</span></code></pre>\n<h2 id=\"until\" tabindex=\"-1\"><a id=\"until\" href=\"https://rootaround.github.io/posts/wiki/sh/#until\"></a> until <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#until\" aria-hidden=\"true\">#</a></h2>\n<p><code>until</code> работает аналогично <code>while</code>, только цикл выполняется пока exit-код первого списка команд <strong>не равен</strong> 0.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># пока нет файла 2.txt цикл будет работать</span>\n$ <span class=\"token keyword\">until</span> <span class=\"token function\">cat</span> <span class=\"token number\">2</span>.txt <span class=\"token operator\">></span>/dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'has no file'</span> <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token operator\">></span> <span class=\"token number\">2</span>.txt <span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">done</span>\n\nhas no <span class=\"token function\">file</span></code></pre>\n<h2 id=\"for\" tabindex=\"-1\"><a id=\"for\" href=\"https://rootaround.github.io/posts/wiki/sh/#for\"></a> for <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#for\" aria-hidden=\"true\">#</a></h2>\n<p>Ситаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> variable <span class=\"token punctuation\">[</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span> word <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>   list\n<span class=\"token keyword\">done</span></code></pre>\n<p>Цикл <code>for</code> позволяет перебирать список слов и на каждом шаге что-то выполнять с элементом</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"i = <span class=\"token variable\">$i</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span>\ni <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\ni <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\ni <span class=\"token operator\">=</span> <span class=\"token number\">3</span></code></pre>\n<p>С возможность подстановки результата команды (command substitution) - <code>$(command)</code> - цикл <code>for</code> позволяет перебирать все что угодно. Command substitution и другие полезные возможности рассмотрим в следующей статье.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># команда ls выдает список файлов в текущей директории</span>\n<span class=\"token comment\"># выдает в строку разделенные пробелами</span>\n$ <span class=\"token function\">ls</span>\n<span class=\"token number\">1</span>.txt <span class=\"token number\">2</span>.txt <span class=\"token number\">3</span>.txt\n\n<span class=\"token comment\"># используя for и command substitution</span>\n<span class=\"token comment\"># можем перебрать в цикле список файлов</span>\n$ <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"file = <span class=\"token variable\">$file</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span>\n<span class=\"token function\">file</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>.txt\n<span class=\"token function\">file</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span>.txt\n<span class=\"token function\">file</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>.txt</code></pre>\n<h2 id=\"break-continue\" tabindex=\"-1\"><a id=\"break-continue\" href=\"https://rootaround.github.io/posts/wiki/sh/#break-continue\"></a> break, continue <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#break-continue\" aria-hidden=\"true\">#</a></h2>\n<p>синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n<span class=\"token builtin class-name\">continue</span> <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre>\n<ul>\n<li><code>break</code> - прерывает цикл <code>for</code> или <code>while</code> (<code>until</code>)</li>\n<li><code>continue</code> - переход на следующую итерацию цикла</li>\n</ul>\n<p>Если есть вложенные циклы, то можно указывая n применять <code>break</code> или <code>continue</code> для нескольких циклов</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">do</span> <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">j</span> <span class=\"token keyword\">in</span> a b c<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$i</span> - <span class=\"token variable\">$j</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">break</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">done</span>\n<span class=\"token number\">1</span> - a\n<span class=\"token number\">2</span> - a\n<span class=\"token number\">3</span> - a\n<span class=\"token comment\"># каждый раз второй цикл будет прерываться на первой итерации</span>\n<span class=\"token comment\"># если поменять на break 2 то будет выведено только 1 - a</span></code></pre>\n<h2 id=\"case\" tabindex=\"-1\"><a id=\"case\" href=\"https://rootaround.github.io/posts/wiki/sh/#case\"></a> case <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#case\" aria-hidden=\"true\">#</a></h2>\n<p>Синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">case</span> word <span class=\"token keyword\">in</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">]</span>pattern<span class=\"token punctuation\">)</span> list <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">..</span>.\n<span class=\"token keyword\">esac</span></code></pre>\n<p>Проверяет соответствие word одному или нескольким паттернам, выполняется список команд у паттерна, который совпадает первым.</p>\n<p>завершающий <code>esac</code> это <code>case</code> наоборот, также как <code>if</code> и <code>fi</code>, кто-то придумал - так и осталось (или там какая-то другая история) 😃</p>\n<p>В самом простом виде в <code>case</code> можно выполнять команды или устанавливать переменные или и то и другое вместе</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">2</span>\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span>\n  <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'2'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p>Первую круглую скобку можно опустить. Кроме указания полных значений можно использовать Shell Patterns.</p>\n<p>Shell patterns позволяют указывать паттерны нестрогого соответствия для строк.</p>\n<p>В Shell Patterns могут использоваться мета-символы <code>! * ? [</code></p>\n<p><a id=\"case-asterisk\" href=\"https://rootaround.github.io/posts/wiki/sh/#case-asterisk\"></a> <code>*</code> - соответвует любой последовательности символов, можно использовать как <code>case</code> по умолчанию.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n*<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'default'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p><a id=\"case-question\" href=\"https://rootaround.github.io/posts/wiki/sh/#case-question\"></a> <code>?</code> - соответствует одному любому символу</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">1</span>??<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'100 or 1??'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p><a id=\"case-bracket\" href=\"https://rootaround.github.io/posts/wiki/sh/#case-bracket\"></a> <code>[</code> - позволяет указать класс символов, внутри можно указать конкретные символы или диапазон символов, также можно комбинировать с другими мета-символами</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> a100\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>ab<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span>-9<span class=\"token punctuation\">]</span>*<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'ab1-9'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p>Cимволы <code>]</code> и <code>-</code> тоже можно использовать как символы внутри последовательности. Для этого символ <code>]</code> нужно разместить сразу после открывающей фигурной скобки <code>[</code> (но после <code>!</code>, если используется). Символ <code>-</code> нужно разместить первым или последним внутри класса символов.</p>\n<p><a id=\"case-excl-mark\" href=\"https://rootaround.github.io/posts/wiki/sh/#case-excl-mark\"></a> <code>!</code> - используется внутри класса символов и означает <strong>несоответствие</strong> классу.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> a100\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token operator\">!</span>ab<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span>-9<span class=\"token punctuation\">]</span>*<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'c1-9'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span>\n\n<span class=\"token comment\"># последний паттерн сработает и выведет c1-9 если i будет равно c100</span></code></pre>\n<p> </p>\n<hr />\n<h1 id=\"functions\" tabindex=\"-1\">Functions <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#functions\" aria-hidden=\"true\">#</a></h1>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function-name function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">command</span>\n  <span class=\"token punctuation\">..</span>.\n  <span class=\"token builtin class-name\">return</span> <span class=\"token punctuation\">[</span>exitstatus<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Функции могут содержать всего одну команду и записываться без фигурных скобок</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ hello<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span>\n$ hello\nHello</code></pre>\n<p>Или несколько команд</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span>\n<span class=\"token punctuation\">}</span>\n$ hello\nHello\nWorld</code></pre>\n<p>Каждая функция работает как обычная команда-программа и возвращает exit-код. По умолчанию возвращается 0, но можно вернуть нужный exit-код c помощью return. При этом выполнение функции прекращается на return.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span>\n<span class=\"token builtin class-name\">return</span> <span class=\"token number\">100</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># World не выводится</span>\n$ hello\nHello\n\n<span class=\"token comment\"># $? содержит exit-код предыдущей команды</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">100</span></code></pre>\n<p> </p>\n<h2 id=\"parametry-i-peremennye\" tabindex=\"-1\"><a id=\"parameters-variables\" href=\"https://rootaround.github.io/posts/wiki/sh/#parameters-variables\"></a> Параметры и переменные <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#parametry-i-peremennye\" aria-hidden=\"true\">#</a></h2>\n<p>Параметры (Parameters) могут позиционными и специальными, а параметры с именем называются переменными (Variables).</p>\n<h3 id=\"poziczionnye-parametry-positional-parameters\" tabindex=\"-1\"><a id=\"postional-parameters\" href=\"https://rootaround.github.io/posts/wiki/sh/#postional-parameters\"></a> Позиционные параметры - Positional Parameters <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#poziczionnye-parametry-positional-parameters\" aria-hidden=\"true\">#</a></h3>\n<p>При запуске скрипта все параметры перечисленные после команды являются позиционными параметрами и ash позволяет обращаться к ним по номерам, начиная с 1.</p>\n<p>В параметре <code>$0</code> хранится путь к текущему скрипту или путь к shell, если запущен интерактивный режим</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># параметр $0 самого shell хранит путь к shell-программе</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$0</span>\n/usr/bin/ash\n\n$ <span class=\"token function\">cat</span> ./test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$0='</span><span class=\"token variable\">$0</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$1='</span><span class=\"token variable\">$1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$2='</span><span class=\"token variable\">$2</span>\n\n<span class=\"token comment\"># передаем пару параметров скрипту test.sh</span>\n$ ash ./test.sh first second\n<span class=\"token variable\">$0</span><span class=\"token operator\">=</span>./test.sh\n<span class=\"token variable\">$1</span><span class=\"token operator\">=</span>first\n<span class=\"token variable\">$2</span><span class=\"token operator\">=</span>second</code></pre>\n<p>Точно такая же логика с позиционными параметрами работает и для функций. В <code>$0</code> будет содержаться путь к shell, а параметры в функции можно передавать аналогично скриптам</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$0='</span><span class=\"token variable\">$0</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n$ hello World\n<span class=\"token variable\">$0</span><span class=\"token operator\">=</span>/usr/bin/ash\nHello, World</code></pre>\n<p>Позиционные параметры в скриптах и функциях можно переопределять с помощью builtin-команды <code>set</code> (подробно синтаксис set разберем в отдельной статье про builtin-команды)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span> and <span class=\"token variable\">$2</span>\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin class-name\">set</span> Beavis Butthead<span class=\"token punctuation\">;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span> and <span class=\"token variable\">$2</span>\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n$ hello Rick Morty\nHello, Rick and Morty\nHello, Beavis and Butthead</code></pre>\n<h3 id=\"peremennye-variables\" tabindex=\"-1\"><a id=\"variables\" href=\"https://rootaround.github.io/posts/wiki/sh/#variables\"></a> Переменные - Variables <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#peremennye-variables\" aria-hidden=\"true\">#</a></h3>\n<p>Shell-переменные можно использовать внутри скриптов для хранения значений</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n$ <span class=\"token assign-left variable\">b</span><span class=\"token operator\">=</span><span class=\"token number\">2</span>\n$ <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$a</span>-<span class=\"token variable\">$b</span>-<span class=\"token variable\">$TEST</span>\"</span>\n<span class=\"token number\">1</span>-2-100500</code></pre>\n<p>Но эти параметры не передаются при вызовах команд в environment-переменные, можно делать вручную задавать environment-переменные для каждой команды</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> ./test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$TEST='</span><span class=\"token variable\">$TEST</span>\n\n<span class=\"token comment\"># переменная TEST будет пуста</span>\n$ ./test.sh\n<span class=\"token variable\">$TEST</span><span class=\"token operator\">=</span>\n\n<span class=\"token comment\"># передаем значение переменной TEST на момент вызова</span>\n$ <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> ./test.sh\n<span class=\"token variable\">$TEST</span><span class=\"token operator\">=</span><span class=\"token number\">1</span></code></pre>\n<p>Для того чтобы shell-переменные передавались в окружение (environment) всем выполняемым командам, нужно экспортировать переменную</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span>\n\n$ ./test.sh\n<span class=\"token variable\">$TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span></code></pre>\n<h3 id=\"peremennye-v-funkcziyah\" tabindex=\"-1\"><a id=\"function-variables\" href=\"https://rootaround.github.io/posts/wiki/sh/#function-variables\"></a> Переменные в функциях <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#peremennye-v-funkcziyah\" aria-hidden=\"true\">#</a></h3>\n<p>В функциях видны все shell-переменные (и environment-переменные тоже) — их можно использовать внутри.</p>\n<p>Также все команды, выполненные внутри функций влияют на shell, в общем все точно также как и при выполнении обычных команд без функции. Чтобы команды не влияли на текущий shell можно <a href=\"https://rootaround.github.io/posts/wiki/sh/#grouping-parentheses\">группировать их в круглых скобках </a>.</p>\n<h3 id=\"lokalnye-peremennye-v-funkcziyah\" tabindex=\"-1\"><a id=\"local-function-variables\" href=\"https://rootaround.github.io/posts/wiki/sh/#local-function-variables\"></a> Локальные переменные в функциях <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#lokalnye-peremennye-v-funkcziyah\" aria-hidden=\"true\">#</a></h3>\n<p>Если определенные переменные нужны только внутри функции можно воспользоваться builtin-функцией local.</p>\n<p>Команда <code>local</code> должна быть вызвана в начале функции и должна содержать имя локальной переменной. Локальные переменные никак не инициализируются и задавать значения им нужно отдельно.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># в shell своя переменная name</span>\n$ <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino\n\n$ <span class=\"token function-name function\">hello</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">local</span> name <span class=\"token comment\"># в функции своя переменная name</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'local name='</span><span class=\"token variable\">$name</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'local name='</span><span class=\"token variable\">$name</span>\n<span class=\"token punctuation\">}</span>\n\n$ hello\n<span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino\n<span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n\n<span class=\"token comment\"># в shell переменная не поменялась</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'name='</span><span class=\"token variable\">$name</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino</code></pre>\n<p>Кроме этого scope локальных переменных сохраняется при создании вложенных функций - то есть для вложенной функции будет своя переменная, а не глобальная.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino\n\n$ <span class=\"token function-name function\">hello</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">local</span> name\n  <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'name='</span><span class=\"token variable\">$name</span>\n\n  <span class=\"token function-name function\">bang</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'bang name='</span><span class=\"token variable\">$name</span> <span class=\"token punctuation\">}</span>\n\n  bang\n<span class=\"token punctuation\">}</span>\n\n\n$ hello\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n<span class=\"token comment\"># в функции bang переиспользуется локальная переменная name</span>\n<span class=\"token comment\"># из функции hello</span>\nbang <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n\n<span class=\"token comment\"># в shell осталась своя переменная</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$name</span>\nPachino</code></pre>\n<p>Вместо имени переменной в <code>local</code> можно указать <code>-</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">local</span> -\n<span class=\"token comment\"># ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>В этом случае все установленные опции с помощью команды <code>set</code> будут локальными и вернуться к своим значениям при выходе из функции.</p>\n<h2 id=\"potoki-v-funkcziyah\" tabindex=\"-1\"><a id=\"function-streams\" href=\"https://rootaround.github.io/posts/wiki/sh/#function-streams\"></a> Потоки в функциях <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#potoki-v-funkcziyah\" aria-hidden=\"true\">#</a></h2>\n<p>Раз функция ведет себя как команда, значит внутри нее можно работать с потоками и использовать функции в пайплайнах</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># передаем в cat данные из stdin-потока</span>\n$ hello <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span> <span class=\"token function\">cat</span> <span class=\"token operator\">&lt;</span><span class=\"token file-descriptor important\">&amp;0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span> <span class=\"token operator\">|</span> hello\nHello\nWorld</code></pre>\n<p>stdout и stderr- потоки у функции также свои</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n$ hello\nHello\nWorld\n\n<span class=\"token comment\"># перенаправляем stderr в /dev/null</span>\n$ hello <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>/dev/null\nHello</code></pre>\n<p> </p>\n<hr />\n<h1 id=\"redirections\" tabindex=\"-1\">Redirections <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#redirections\" aria-hidden=\"true\">#</a></h1>\n<p>про потоки процесса и их нумерацию:</p>\n<ul>\n<li>0 - stdin - входной поток процесса, через него могут передаваться данные из другой команды</li>\n<li>1 - stdout - выходной поток процесса, в этот поток процесс может писать результаты</li>\n<li>2 - stderr - поток для ошибок и отладки</li>\n</ul>\n<p>Все перенаправления потоков, рассмотренные дальше, действуют только в рамках текущей команды или набора команд.</p>\n<p> </p>\n<h2 id=\"operator-n-file\" tabindex=\"-1\"><a id=\"operator-n-to-file\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-to-file\"></a> оператор <code>[n]&gt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file\" aria-hidden=\"true\">#</a></h2>\n<p>Потоки можно перенаправлять в файлы</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 123 будет записано в файл</span>\n<span class=\"token comment\"># тут мы перенаправили поток stdout в файл tmp.txt</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">></span> tmp.txt</code></pre>\n<p>Оператор <code>&gt;</code> позволяет перенаправить поток в файл по номеру потока. Приведенная выше команда это краткая запись команды. Полная запись выглядит так</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># перенаправляем stdout в файл tmp.txt</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> tmp.txt</code></pre>\n<p>Аналогичным образом можно перенаправить stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'error'</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> errors.log</code></pre>\n<p>Оператор <code>&gt;</code> полностью перезаписывает содержимое файла новыми данными, если файл уже существует. Если файла нет - создает и записывает данные.</p>\n<p>Для защиты от перезаписи файлов, например, при отладке каких-то уже существующих скриптов, существует аргумент <code>-С</code> (<a href=\"https://rootaround.github.io/posts/wiki/sh/#noclobber-c\">noclobber</a>), который предотвращает перезапись файла — с этим аргументом ash будет выдавать ошибку, если файл уже существует.</p>\n<h2 id=\"operator-n-file-1\" tabindex=\"-1\"><a id=\"operator-n-to-stick-file\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-to-stick-file\"></a> оператор <code>[n]&gt;| file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file-1\" aria-hidden=\"true\">#</a></h2>\n<p>Делает все то же самое что и предыдущий оператор, но при запуске с аргументом <code>-C</code> (<a href=\"https://rootaround.github.io/posts/wiki/sh/#noclobber-c\">noclobber</a>) файл все равно будет перезаписан — такой force для перенаправления потока в файл.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># скрипт записывает текст в файл с использованием оператора ></span>\n$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">></span> tmp.txt\n\n<span class=\"token comment\"># выполняем - в файл tmp.txt записывается 123</span>\n$ ash test.sh\n\n<span class=\"token comment\"># еще раз выполняем тот же скрипт,</span>\n<span class=\"token comment\"># файл tmp.txt будет перезаписан с тем же текстом 123</span>\n$ ash test.sh\n\n<span class=\"token comment\"># с аргументом -C при перенаправлении с оператором > будет ошибка</span>\n$ ash <span class=\"token parameter variable\">-C</span> test.sh\ntest.sh: line <span class=\"token number\">1</span>: can't create tmp.txt: File exists\n\n<span class=\"token comment\"># если переделать оператор > на >|</span>\n$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1234</span> <span class=\"token operator\">>|</span> tmp.txt\n\n<span class=\"token comment\"># то даже с аргументом -C файл будет перезаписан</span>\n$ ash <span class=\"token parameter variable\">-C</span> test.sh</code></pre>\n<h2 id=\"operator-n-file-2\" tabindex=\"-1\"><a id=\"operator-n-double-to-file\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-double-to-file\"></a> оператор <code>[n]&gt;&gt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file-2\" aria-hidden=\"true\">#</a></h2>\n<p>Дописывает данные из потока в конец файла, если файла нет - то создает</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">567</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>>></span> tmp.txt\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">890</span> <span class=\"token operator\">>></span> tmp.txt\n$ <span class=\"token function\">cat</span> tmp.txt\n<span class=\"token number\">1234</span>\n<span class=\"token number\">567</span>\n<span class=\"token number\">890</span></code></pre>\n<h2 id=\"operator-n-file-3\" tabindex=\"-1\"><a id=\"operator-n-from-file\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-from-file\"></a> оператор <code>[n]&lt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file-3\" aria-hidden=\"true\">#</a></h2>\n<p>чтение потока из файла</p>\n<p>В основном используется для чтения stdin</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># команда cat выводит stdin</span>\n<span class=\"token comment\"># или содержимое файла (если указан путь к файлу)</span>\n<span class=\"token comment\"># будет выведено содержимое stdin,</span>\n<span class=\"token comment\"># которое будет прочитано из файла tmp.txt</span>\n$ <span class=\"token function\">cat</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> tmp.txt\n<span class=\"token number\">1234</span>\n<span class=\"token number\">567</span>\n<span class=\"token number\">890</span>\n\n<span class=\"token comment\"># сокращенная запись без указания номера потока</span>\n$ <span class=\"token function\">cat</span> <span class=\"token operator\">&lt;</span> tmp.txt\n<span class=\"token comment\"># вывод такой же</span></code></pre>\n<p>Оператор перенаправления может быть записан и до команды</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token operator\">&lt;</span> tmp.txt <span class=\"token function\">cat</span>\n<span class=\"token comment\"># командой cat из stdin будет выведено содержимое файла tmp.txt</span></code></pre>\n<h2 id=\"operator-n1-and-n2\" tabindex=\"-1\"><a id=\"operator-n-to-descriptor\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-to-descriptor\"></a> оператор <code>[n1]&gt;&amp;n2</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n1-and-n2\" aria-hidden=\"true\">#</a></h2>\n<p>Перенаправляет поток n1 (или stdout - 1 по умолчанию) в поток с номером n2</p>\n<p>Интерактивный шелл тоже процесс и у него есть свои stdin, stdout, stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># пишем в stdout - поток с номером 1</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'out'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;1</span>\nout\n\n<span class=\"token comment\"># пишем в stderr - поток с номером 2</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'error'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span>\nerror</code></pre>\n<p>Вывод обеих команд будет отображен в консоли, потому что для интерактивного шелла весь вывод идет на экран.</p>\n<p>Для скриптов также можно писать отдельно в stdout и stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># скрипт пишет раздельно в stdout и в stderr</span>\n$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'out'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'error'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span>\n\n<span class=\"token comment\"># если просто выполнить скрипт, то всё увидим в консоли</span>\n$ ash test.sh\nout\nerror\n\n<span class=\"token comment\"># С помощью оператора ></span>\n<span class=\"token comment\"># мы можем перенаправить stdout и stderr в разные файлы</span>\n$ ash test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> stdout.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>stderr.txt\n$ <span class=\"token function\">cat</span> stdout.txt\nout\n$ <span class=\"token function\">cat</span> stderr.txt\nerror</code></pre>\n<p>Еще с помощью этого оператора можно наоборот сводить потоки, например, stdout и stderr в один файл</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> stdout.txt\nerror\n\n<span class=\"token comment\"># в консоли вывелось error,</span>\n<span class=\"token comment\"># потому что sterr не перенаправлен и отображается в консоль</span>\n\n<span class=\"token comment\"># заворачиваем поток stderr в stdout</span>\n$ ash test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> stdout.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n\n<span class=\"token comment\"># и stdout и stderr записались в файл stdout.txt</span>\n$ <span class=\"token function\">cat</span> stdout.txt\nout\nerror</code></pre>\n<h2 id=\"mnogostrochnye-dannye-dlya-potoka-here-document-heredoc\" tabindex=\"-1\"><a id=\"heredoc\" href=\"https://rootaround.github.io/posts/wiki/sh/#heredoc\"></a> Многострочные данные для потока - here-document, heredoc <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#mnogostrochnye-dannye-dlya-potoka-here-document-heredoc\" aria-hidden=\"true\">#</a></h2>\n<p>Во всех примерах до этого мы рассмотрели перенаправления в файл и из файла. С помощью backslash(/) можно визуально переносить строки для лучшей читаемости и перенаправить их на вход другой команде (об этом в следующих статьях). Но при этом переносы строк не будут выводится</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"very very very \\\nlong long long \\\ntext text text\"</span>\nvery very very long long long text text text</code></pre>\n<p>Для решения этой проблемы в ash существует синтаксис here-document, который в общем виде выглядит так</p>\n<pre><code>[n]&lt;&lt; delimiter\n    here-doc-text ...\ndelimiter\n</code></pre>\n<p>delimiter может быть любой последовательностью символов, первый раз после указания delimiter на следующей строке должны начаться данные, после второго указания delimiter с начала строки данные завершились. Обычно delimiter указывают EOL - как аббревиатура End Of Line, но он может быть и другой последовательностью символов.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span><span class=\"token operator\">&lt;</span> EOL\n<span class=\"token operator\">></span> very very very\n<span class=\"token operator\">></span> long long long\n<span class=\"token operator\">></span> text text text\n<span class=\"token operator\">></span> EOL\nvery very very\nlong long long\ntext text text</code></pre>\n<p>В интерактивном режиме после EOL и переноса строки shell символом <code>&gt;</code> в начале строки подсказывает что ввод команды продолжается.</p>\n<p>Для скриптов heredoc используется аналогично</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOL\n1\n2\n3\nEOL</span>\n$ ash test.sh\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Если требуется в скрипте визуально отделить содержимое heredoc, можно использовать символ табуляции и добавить оператор <code>&lt;&lt;-</code> – в этом случае shell удалит все табы с начала строк</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;-</span> <span class=\"token string\">EOL\n&lt;tab>1\n&lt;tab>2\n&lt;tab>3\nEOL</span>\n$ ash test.sh\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Кроме этого внутри heredoc можно использовать shell-переменные</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOL\npwd = <span class=\"token environment constant\">$PWD</span>\nEOL</span>\n$ ash test.sh\n<span class=\"token builtin class-name\">pwd</span> <span class=\"token operator\">=</span> /home/ubuntu</code></pre>\n<p>Чтобы текст внутри heredoc обрабатывался как обычные символы без подстановки переменных, нужно первый delimiter заключить в кавычки (двойные или одинарные)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'EOL'\npwd = $PWD\nEOL</span>\n$ ash test.sh\n<span class=\"token builtin class-name\">pwd</span> <span class=\"token operator\">=</span> <span class=\"token environment constant\">$PWD</span></code></pre>\n<h2 id=\"rabota-s-deskriptorami\" tabindex=\"-1\"><a id=\"descriptors\" href=\"https://rootaround.github.io/posts/wiki/sh/#descriptors\"></a> Работа с дескрипторами <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#rabota-s-deskriptorami\" aria-hidden=\"true\">#</a></h2>\n<p>Еще одна фича для работы с дескрипторами файлов — это возможность открыть файл в какой-то номер дескриптора, номера могут быть от 0 до 9.</p>\n<p>Для того чтобы использовать номер дескриптора в скрипте или интерактивном shell для нескольких команд нужно использовать builtin-команду exec (подробнее мы рассмотрим ее в следующих статьях).</p>\n<p>Сейчас нам нужно знать что все перенаправления выполненные в exec становятся постоянными (permanant) в рамках шелла или скрипта, то есть открытые дескрипторы можно использовать для последующих команд.</p>\n<h3 id=\"operator-n-file-4\" tabindex=\"-1\"><a id=\"operator-open-descriptor\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-open-descriptor\"></a> оператор <code>[n]&lt;&gt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n-file-4\" aria-hidden=\"true\">#</a></h3>\n<p>Позволяет открыть дескриптор файла на чтение и запись</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># открываем поток (дескриптор файла) с номером 3 для файла tmp.txt</span>\n$ <span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;></span> ./tmp.txt\n<span class=\"token comment\"># так как команда была выполнена с помощью exec</span>\n<span class=\"token comment\"># дескриптор доступен для следующих команд</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'2'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'3'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token function\">cat</span> ./tmp.txt\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<h3 id=\"operator-n\" tabindex=\"-1\"><a id=\"operator-close-descriptor\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-close-descriptor\"></a> оператор <code>[n]&gt;-</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#operator-n\" aria-hidden=\"true\">#</a></h3>\n<p>Закрыть дескриптор файла</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># продолжая предыдущий пример</span>\n$ <span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span>-\n<span class=\"token comment\"># дескриптор файла tmp.txt закрыт</span>\n<span class=\"token comment\"># если снова открыть дескриптор,</span>\n<span class=\"token comment\"># то запись или чтение из файла начнется с начала</span>\n$ <span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;></span> ./tmp.txt\n<span class=\"token comment\"># читаем из дескриптора 2 байта (1\\n) - единицу и перенос строки</span>\n$ <span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;</span><span class=\"token file-descriptor important\">&amp;3</span>\n<span class=\"token comment\"># сейчас указатель дексриптора указывает на вторую строку (2\\n)</span>\n<span class=\"token comment\"># запишем 9</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">9</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token function\">cat</span> ./tmp.txt\n<span class=\"token number\">1</span>\n<span class=\"token number\">9</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Аналогично можно работать с input с помощью операторов <code>[n1]&lt;&amp;n2</code>, <code>[n]&lt;-</code></p>\n<p> </p>\n<hr />\n<h1 id=\"variables\" tabindex=\"-1\">Variables <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#variables\" aria-hidden=\"true\">#</a></h1>\n<p>Команда запускает процесс, у процесса могут быть переменные окружения (environment variables, env vars). Переменные окружения для конкретной команды можно задать непосредственно при вызове:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token function\">env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token comment\"># &lt;&lt;&lt; переменная 'a' есть в переменных окружения</span></code></pre>\n<p>Вообще и в интерактивном шелле и в скриптах все что соответствует паттертну <code>name=value</code> с начала строки (или после служебного слова) считается переменной и если после переменных следует команда, то все эти переменные попадут в переменные окружения процесса запущенного этой командой:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">b</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token function\">env</span>\n<span class=\"token comment\"># ...</span>\n<span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\">b</span><span class=\"token operator\">=</span><span class=\"token number\">2</span></code></pre>\n<p>Если переменные указаны без команды, то они определяются как переменные шелла - shell variables.</p>\n<p>Shell variables доступны для подстановки в самом шелле, но во все выполняемые команды передаются только environment variables.</p>\n<p>Shell-переменные (в том числе environment-переменные) можно посмотреть builtin-командой <code>set</code>, а env-переменные командой <code>env</code> или <code>export</code>.</p>\n<p>Несколько примеров чтобы стало понятнее</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># определяем shell-переменную my_test_var</span>\n$ <span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token comment\"># смотрим что переменная определилась</span>\n<span class=\"token comment\"># в результатах set выводятся вообще все переменные,</span>\n<span class=\"token comment\"># в том числе environment variables</span>\n$ <span class=\"token builtin class-name\">set</span>\n<span class=\"token comment\"># ...</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PS4</span></span><span class=\"token operator\">=</span><span class=\"token string\">'+ '</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span><span class=\"token string\">'/home/ubuntu'</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token string\">'1'</span>\n<span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token string\">'1'</span> <span class=\"token comment\"># &lt;&lt;&lt; тут есть переменная 'my_test_var'</span>\n\n<span class=\"token comment\"># так как my_test_var еще не environment variable,</span>\n<span class=\"token comment\"># ее нет в выводе команды env</span>\n$ <span class=\"token function\">env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n\n<span class=\"token comment\"># но ее можно использовать в самом шелле</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'my_test_var = '</span><span class=\"token variable\">$my_test_var</span>\nmy_test_var <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\"># для того чтобы переменная стала environment-переменной</span>\n<span class=\"token comment\"># ее нужно экспортировать</span>\n$ <span class=\"token builtin class-name\">export</span> my_test_var\n\n<span class=\"token comment\"># теперь переменная my_test_var является environment-переменной</span>\n<span class=\"token comment\"># и передаётся в environment всех команд запущенных в шелле</span>\n$ <span class=\"token function\">env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token comment\"># &lt;&lt;&lt;</span>\n\n<span class=\"token comment\"># для конкретного вызова команды</span>\n<span class=\"token comment\"># environment-переменную всегда можно переопределить</span>\n$ <span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span> <span class=\"token function\">env</span>\n<span class=\"token comment\"># ...</span>\n<span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span></code></pre>\n<p>Пример показывает что все переменные доступны для подстановки внутри shell, но только environment-переменные передаются в окружение всем командам, выполняемым в shell.</p>\n<p>В названии переменных могут использоваться символы латинского алфавита, числа и символ подчеркивания, название переменной не может начинаться с числа.</p>\n<p>Для более явного разделения переменных существует негласное правило:</p>\n<p>environment-переменные пишутся заглавными буквами, а обычные shell-переменные строчными</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># PATH - environment-переменная</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n\n<span class=\"token comment\"># my_test_var - обычная shell-переменная</span>\n$ <span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">1</span></code></pre>\n<h2 id=\"environment-variables\" tabindex=\"-1\">Environment variables <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#environment-variables\" aria-hidden=\"true\">#</a></h2>\n<h3 id=\"home\" tabindex=\"-1\">HOME <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#home\" aria-hidden=\"true\">#</a></h3>\n<p>Домашняя директория пользователя и passwd файла, переменная устанавливается командой login и используется множеством разных команд, например, командой cd без параметров для перехода в домашнюю директорию пользователя</p>\n<p>Для проверки можно запустить ash без env-переменных от root пользователя и выполнить команду login</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">## запускаем ash без env-параметров текущего shell и под root</span>\n<span class=\"token comment\">## root - нужен для запуска login,</span>\n<span class=\"token comment\">## иначе будет ошибка login: must be suid to work properly</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">env</span> <span class=\"token parameter variable\">-i</span> /usr/bin/ash\n\n<span class=\"token comment\">## далее одинарная решетка это prompt root пользователя</span>\n<span class=\"token comment\"># env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n\n<span class=\"token comment\"># login -f ubuntu</span>\n<span class=\"token comment\">## ...</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/home/ubuntu/bin:/home/ubuntu/.local/bin:/data/bin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">USER</span></span><span class=\"token operator\">=</span>ubuntu\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">HOME</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token comment\">## ...</span></code></pre>\n<h3 id=\"path\" tabindex=\"-1\">PATH <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#path\" aria-hidden=\"true\">#</a></h3>\n<p>Список директорий разделенный двоеточиями.\nВ этих директориях shell ищет программы.</p>\n<h3 id=\"cdpath\" tabindex=\"-1\">CDPATH <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#cdpath\" aria-hidden=\"true\">#</a></h3>\n<p>Путь относительно которого работает команда cd</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># задаем CDPATH=/home/ubuntu</span>\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">CDPATH</span><span class=\"token operator\">=</span>/home/ubuntu\n\n$ <span class=\"token builtin class-name\">cd</span>\n/home/ubuntu\n\n<span class=\"token comment\"># теперь все относительные пути без указания первого слэша</span>\n<span class=\"token comment\"># будут считаться относительно /home/ubuntu</span>\n$ <span class=\"token builtin class-name\">cd</span> tmp\n<span class=\"token comment\"># мы в /home/ubuntu/tmp - если такая директория существует</span></code></pre>\n<h3 id=\"mail\" tabindex=\"-1\">MAIL <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#mail\" aria-hidden=\"true\">#</a></h3>\n<p>Следующие 3 env-переменных нужны для проверки почты, точнее в самом shell реализовано слежение за изменением в файле</p>\n<p>в MAIL может содержаться путь к файлу, за изменениями которого нужно следить.</p>\n<h3 id=\"mailcheck\" tabindex=\"-1\">MAILCHECK <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#mailcheck\" aria-hidden=\"true\">#</a></h3>\n<p>в MAILCHECK устанавливается время в секундах, через сколько нужно проверять файл или файлы указанные в MAIL или MAILPATH</p>\n<p>По умолчанию = 60</p>\n<p>Если поставить 0, то проверка будет происходит после каждого выполнения команды, В доке формулируется так “If set to 0, the check will occur at each prompt”, то есть при каждом показе приглашения к вводу команды.</p>\n<h3 id=\"mailpath\" tabindex=\"-1\">MAILPATH <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#mailpath\" aria-hidden=\"true\">#</a></h3>\n<p>в MAILPATH через двоеточие <code>:</code> может быть указано несколько файлов, которые нужно проверять</p>\n<p>если указан MAILPATH, то MAIL игнорируется.</p>\n<p>работает это так</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">touch</span> ~/mail.txt\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">MAILPATH</span><span class=\"token operator\">=</span>/home/ubuntu/mail.txt\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">MAILCHECK</span></span><span class=\"token operator\">=</span><span class=\"token number\">5</span>\n\n<span class=\"token comment\"># меняем файл, в случае почтовых программ они меняют файл</span>\n<span class=\"token comment\"># и bash видимо умеет их парсить и выводить даже количество писем</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token operator\">>></span> ~/mail.txt\n\n<span class=\"token comment\"># далее после выполнения команды или просто пустой строки ash выведет</span>\n$\nyou have mail\n$\n<span class=\"token comment\"># то есть проверка происходит перед показом prompt</span></code></pre>\n<h3 id=\"ps1\" tabindex=\"-1\">PS1 <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#ps1\" aria-hidden=\"true\">#</a></h3>\n<p>Prompt String - это основная подсказка к вводу команды и по умолчанию для обычного пользователя это переменная равна <code>$ </code> (доллар и пробел), для суперпользователя root <code># </code> (решетка и пробел)</p>\n<p>значение может содержать не специальные последовательности</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># например, по умолчанию PS1 в ash выводит еще и текущую директорию</span>\n<span class=\"token comment\"># сейчас мы в домашней директории</span>\n~ $\n\n<span class=\"token comment\"># а переменная равна</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PS1</span>\n<span class=\"token punctuation\">\\</span>w <span class=\"token punctuation\">\\</span>$</code></pre>\n<p>Подробнее про эти опции поговорим в статьях про <a href=\"https://rootaround.github.io/posts/wiki/sh/\">bash</a></p>\n<h3 id=\"ps2\" tabindex=\"-1\">PS2 <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#ps2\" aria-hidden=\"true\">#</a></h3>\n<p>Подсказка ввода для многострочных команд. По умолчанию <code>&gt; </code></p>\n<pre><code>$ (\n&gt; echo 123\n&gt; )\n123\n$\n</code></pre>\n<h3 id=\"ps3\" tabindex=\"-1\">PS3 <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#ps3\" aria-hidden=\"true\">#</a></h3>\n<p>Почему-то не описано в документации, возможно в ash не используется</p>\n<h3 id=\"ps4\" tabindex=\"-1\">PS4 <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#ps4\" aria-hidden=\"true\">#</a></h3>\n<p>В случае если включена трассировка опцией <code>-x</code>, перед каждой выполненной командой выводится значение PS4</p>\n<p>По умолчанию равно <code>+ </code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">set</span> <span class=\"token parameter variable\">-x</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n+ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token number\">1</span>\n+ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n<span class=\"token number\">2</span>\n$</code></pre>\n<h3 id=\"ifs\" tabindex=\"-1\"><a id=\"IFS\" href=\"https://rootaround.github.io/posts/wiki/sh/#IFS\"></a> IFS <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#ifs\" aria-hidden=\"true\">#</a></h3>\n<p>Input Field Separators</p>\n<p>Разделители при чтении и выводе параметров - подробнее разберем в следующей статье про Special Parameters (здесь будет ссылка на статью)</p>\n<h3 id=\"term\" tabindex=\"-1\">TERM <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#term\" aria-hidden=\"true\">#</a></h3>\n<p>В переменной содержится название текущего терминала, и используется программами для определения возможностей терминала, например, программа может определить поддерживает ли терминал цвета (xterm или xterm-256color)</p>\n<h3 id=\"histsize\" tabindex=\"-1\">HISTSIZE <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#histsize\" aria-hidden=\"true\">#</a></h3>\n<p>Сколько команд хранить в истории shell’a (это переключение истории команд стрелками)</p>\n<p>По умолчанию равно 15</p>\n<h3 id=\"pwd\" tabindex=\"-1\">PWD <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#pwd\" aria-hidden=\"true\">#</a></h3>\n<p>Текущая директория, эту переменную меняет команда cd</p>\n<h3 id=\"oldpwd\" tabindex=\"-1\">OLDPWD <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#oldpwd\" aria-hidden=\"true\">#</a></h3>\n<p>Предыдущая директория</p>\n<h3 id=\"ppid\" tabindex=\"-1\">PPID <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/wiki/sh/#ppid\" aria-hidden=\"true\">#</a></h3>\n<p>ID процесса текущего shell</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PPID</span>\n<span class=\"token number\">1527</span></code></pre>\n",
      "date_published": "2022-07-27T16:11:00Z"
    },{
      "id": "https://rootaround.github.io/posts/wiki/linux-shells/",
      "url": "https://rootaround.github.io/posts/wiki/linux-shells/",
      "title": "linux shells",
      "content_html": "<ul>\n<li><a href=\"https://rootaround.github.io/tags/ash/\">ash</a></li>\n</ul>\n",
      "date_published": "2022-07-27T16:10:00Z"
    },{
      "id": "https://rootaround.github.io/posts/blog/202207262240/",
      "url": "https://rootaround.github.io/posts/blog/202207262240/",
      "title": "Переехал с hexo на 11ly",
      "content_html": "<p>Переехал с hexo на 11ly - <a href=\"https://www.11ty.dev/\" target=\"_blank\" rel=\"noopener\">https://www.11ty.dev/</a></p>\n<p>Понадобилось, чтобы вести посты и вики в obsidian.</p>\n<p>Почти из коробки завелись obsidian-ссылки вида <a href=\"https://rootaround.github.io/posts/wiki/javascript\">javascript</a>.</p>\n<p>Кроме этого понравилась минималистичная тема базового шаблона и такой же подход eleventy к работе - по сути один конфиг на старте и один пакет, ничего лишнего.</p>\n<p>Пробую, смотрю как летит. 🛫</p>\n",
      "date_published": "2022-07-26T22:40:00Z"
    },{
      "id": "https://rootaround.github.io/posts/drafts/test/",
      "url": "https://rootaround.github.io/posts/drafts/test/",
      "title": "Test",
      "content_html": "<p><a href=\"https://rootaround.github.io/posts/wiki/javascript\">javascript</a></p>\n<h1 id=\"mrk-test-markdown-it-page\" tabindex=\"-1\">mrk test markdown-it page <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#mrk-test-markdown-it-page\" aria-hidden=\"true\">#</a></h1>\n<h1 id=\"n1\" tabindex=\"-1\"><a href=\"https://rootaround.github.io/posts/drafts/\">N1</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#n1\" aria-hidden=\"true\">#</a></h1>\n<script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"></script>\n<div id=\"chart_div\"></div>\n<script type=\"text/javascript\">\ngoogle.charts.load('current', {packages:[\"orgchart\"]});\ngoogle.charts.setOnLoadCallback(drawChart);\n\nfunction drawChart() {\n  var data = new google.visualization.DataTable();\n  data.addColumn('string', 'Name');\n  data.addColumn('string', 'Manager');\n  data.addColumn('string', 'ToolTip');\n\n  // For each orgchart box, provide the name, manager, and tooltip to show.\n  data.addRows([\n    [\n        {\n            v:'Mike',\n            f:'Mike<div style=\"color:red; font-style:italic\">President</div>'\n        },\n        '',\n        'The President'\n    ],\n    [\n        {\n            v:'Jim',\n            f:'Jim<div style=\"color:red; font-style:italic\">Vice President</div>'\n        },\n        'Mike',\n        'VP'\n    ],\n    [\n        'Alice',\n        'Mike',\n        ''\n    ],\n    [\n        'Bob',\n        'Jim',\n        'Bob Sponge'\n    ],\n    [\n        'Carol',\n        'Bob',\n        ''\n    ]\n  ]);\n\n  // Create the chart.\n  var chart = new google.visualization.OrgChart(document.getElementById('chart_div'));\n  // Draw the chart, setting the allowHtml option to true for the tooltips.\n  chart.draw(data, {allowHtml:true});\n}\n</script>\n<p><strong>Advertisement 😃</strong></p>\n<ul>\n<li><strong><a href=\"https://nodeca.github.io/pica/demo/\" target=\"_blank\" rel=\"noopener\">pica</a></strong> - high quality and fast image\nresize in browser.</li>\n<li><strong><a href=\"https://github.com/nodeca/babelfish/\" target=\"_blank\" rel=\"noopener\">babelfish</a></strong> - developer friendly\ni18n with plurals support and easy syntax.</li>\n</ul>\n<p>You will like those projects!</p>\n<hr />\n<h1 id=\"h1-heading\" tabindex=\"-1\">h1 Heading 😎 <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#h1-heading\" aria-hidden=\"true\">#</a></h1>\n<h2 id=\"h2-heading\" tabindex=\"-1\">h2 Heading <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#h2-heading\" aria-hidden=\"true\">#</a></h2>\n<h3 id=\"h3-heading\" tabindex=\"-1\">h3 Heading <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#h3-heading\" aria-hidden=\"true\">#</a></h3>\n<h4 id=\"h4-heading\" tabindex=\"-1\">h4 Heading <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#h4-heading\" aria-hidden=\"true\">#</a></h4>\n<h5>h5 Heading</h5>\n<h6>h6 Heading</h6>\n<h2 id=\"horizontal-rules\" tabindex=\"-1\">Horizontal Rules <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#horizontal-rules\" aria-hidden=\"true\">#</a></h2>\n<hr />\n<hr />\n<hr />\n<h2 id=\"typographic-replacements\" tabindex=\"-1\">Typographic replacements <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#typographic-replacements\" aria-hidden=\"true\">#</a></h2>\n<p>Enable typographer option to see result.</p>\n<p>© © ® ® ™ ™ (p) (P) ±</p>\n<p>test… test… test… test?.. test!..</p>\n<p>!!! ??? , – —</p>\n<p>“Smartypants, double quotes” and ‘single quotes’</p>\n<h2 id=\"emphasis\" tabindex=\"-1\">Emphasis <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#emphasis\" aria-hidden=\"true\">#</a></h2>\n<p><strong>This is bold text</strong></p>\n<p><strong>This is bold text</strong></p>\n<p><em>This is italic text</em></p>\n<p><em>This is italic text</em></p>\n<p><s>Strikethrough</s></p>\n<h2 id=\"blockquotes\" tabindex=\"-1\">Blockquotes <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#blockquotes\" aria-hidden=\"true\">#</a></h2>\n<blockquote>\n<p>Blockquotes can also be nested…</p>\n<blockquote>\n<p>…by using additional greater-than signs right next to each other…</p>\n<blockquote>\n<p>…or with spaces between arrows.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"lists\" tabindex=\"-1\">Lists <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#lists\" aria-hidden=\"true\">#</a></h2>\n<p>Unordered</p>\n<ul>\n<li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li>\n<li>Sub-lists are made by indenting 2 spaces:\n<ul>\n<li>Marker character change forces new list start:\n<ul>\n<li>Ac tristique libero volutpat at</li>\n</ul>\n<ul>\n<li>Facilisis in pretium nisl aliquet</li>\n</ul>\n<ul>\n<li>Nulla volutpat aliquam velit</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Very easy!</li>\n</ul>\n<p>Ordered</p>\n<ol>\n<li>\n<p>Lorem ipsum dolor sit amet</p>\n</li>\n<li>\n<p>Consectetur adipiscing elit</p>\n</li>\n<li>\n<p>Integer molestie lorem at massa</p>\n</li>\n<li>\n<p>You can use sequential numbers…</p>\n</li>\n<li>\n<p>…or keep all the numbers as <code>1.</code></p>\n</li>\n</ol>\n<p>Start numbering with offset:</p>\n<ol start=\"57\">\n<li>foo</li>\n<li>bar</li>\n</ol>\n<h2 id=\"code\" tabindex=\"-1\">Code <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#code\" aria-hidden=\"true\">#</a></h2>\n<p>Inline <code>code</code></p>\n<p>Indented code</p>\n<p>// Some comments\nline 1 of code\nline 2 of code\nline 3 of code</p>\n<p>Block code “fences”</p>\n<pre><code>Sample text here...\n</code></pre>\n<p>Syntax highlighting</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">foo</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">bar</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> bar<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"tables\" tabindex=\"-1\">Tables <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#tables\" aria-hidden=\"true\">#</a></h2>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>data</td>\n<td>path to data files to supply the data that will be passed into templates.</td>\n</tr>\n<tr>\n<td>engine</td>\n<td>engine to be used for processing templates. Handlebars is the default.</td>\n</tr>\n<tr>\n<td>ext</td>\n<td>extension to be used for dest files.</td>\n</tr>\n</tbody>\n</table>\n<p>Right aligned columns</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">Option</th>\n<th style=\"text-align:right\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">data</td>\n<td style=\"text-align:right\">path to data files to supply the data that will be passed into templates.</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">engine</td>\n<td style=\"text-align:right\">engine to be used for processing templates. Handlebars is the default.</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ext</td>\n<td style=\"text-align:right\">extension to be used for dest files.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"links\" tabindex=\"-1\">Links <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#links\" aria-hidden=\"true\">#</a></h2>\n<p><a href=\"http://dev.nodeca.com/\" target=\"_blank\" rel=\"noopener\">link text</a></p>\n<p><a href=\"http://nodeca.github.io/pica/demo/\" title=\"title text!\" target=\"_blank\" rel=\"noopener\">link with title</a></p>\n<p>Autoconverted link <a href=\"https://github.com/nodeca/pica\" target=\"_blank\" rel=\"noopener\">https://github.com/nodeca/pica</a> (enable linkify to see)</p>\n<h2 id=\"images\" tabindex=\"-1\">Images <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#images\" aria-hidden=\"true\">#</a></h2>\n<p><img alt=\"Minion\" loading=\"lazy\" decoding=\"async\" src=\"https://octodex.github.com/images/minion.png\" width=\"undefined\" height=\"undefined\" />\n</p><figure><img alt=\"Stormtroopocat\" loading=\"lazy\" decoding=\"async\" src=\"https://octodex.github.com/images/stormtroopocat.jpg\" width=\"undefined\" height=\"undefined\" /><figcaption>The Stormtroopocat</figcaption></figure><p></p>\n<p>Like links, Images also have a footnote style syntax</p>\n<p></p><figure><img alt=\"Alt text\" loading=\"lazy\" decoding=\"async\" src=\"https://octodex.github.com/images/dojocat.jpg\" width=\"undefined\" height=\"undefined\" /><figcaption>The Dojocat</figcaption></figure><p></p>\n<p>With a reference later in the document defining the URL location:</p>\n<h2 id=\"plugins\" tabindex=\"-1\">Plugins <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#plugins\" aria-hidden=\"true\">#</a></h2>\n<p>The killer feature of <code>markdown-it</code> is very effective support of\n<a href=\"https://www.npmjs.org/browse/keyword/markdown-it-plugin\" target=\"_blank\" rel=\"noopener\">syntax plugins</a>.</p>\n<h3 id=\"emojies\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-emoji\" target=\"_blank\" rel=\"noopener\">Emojies</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#emojies\" aria-hidden=\"true\">#</a></h3>\n<blockquote>\n<p>Classic markup: 😉 :crush: 😢 :tear: 😆 😋</p>\n<p>Shortcuts (emoticons): 😃 😦 😎 😉</p>\n</blockquote>\n<p>see <a href=\"https://github.com/markdown-it/markdown-it-emoji#change-output\" target=\"_blank\" rel=\"noopener\">how to change output</a> with twemoji.</p>\n<h3 id=\"subscript-superscript\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-sub\" target=\"_blank\" rel=\"noopener\">Subscript</a> / <a href=\"https://github.com/markdown-it/markdown-it-sup\" target=\"_blank\" rel=\"noopener\">Superscript</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#subscript-superscript\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>19<sup>th</sup></li>\n<li>H<sub>2</sub>O</li>\n</ul>\n<h3 id=\"ins\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-ins\" target=\"_blank\" rel=\"noopener\">&lt;ins&gt;</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#ins\" aria-hidden=\"true\">#</a></h3>\n<p><ins>Inserted text</ins></p>\n<h3 id=\"mark\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-mark\" target=\"_blank\" rel=\"noopener\">&lt;mark&gt;</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#mark\" aria-hidden=\"true\">#</a></h3>\n<p><mark>Marked text</mark></p>\n<h3 id=\"footnotes\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-footnote\" target=\"_blank\" rel=\"noopener\">Footnotes</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#footnotes\" aria-hidden=\"true\">#</a></h3>\n<p>Footnote 1 link<sup class=\"footnote-ref\"><a href=\"https://rootaround.github.io/posts/drafts/test/#fn1\" id=\"fnref1\">[1]</a></sup>.</p>\n<p>Footnote 2 link<sup class=\"footnote-ref\"><a href=\"https://rootaround.github.io/posts/drafts/test/#fn2\" id=\"fnref2\">[2]</a></sup>.</p>\n<p>Inline footnote<sup class=\"footnote-ref\"><a href=\"https://rootaround.github.io/posts/drafts/test/#fn3\" id=\"fnref3\">[3]</a></sup> definition.</p>\n<p>Duplicated footnote reference<sup class=\"footnote-ref\"><a href=\"https://rootaround.github.io/posts/drafts/test/#fn2\" id=\"fnref2:1\">[2:1]</a></sup>.</p>\n<h3 id=\"definition-lists\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-deflist\" target=\"_blank\" rel=\"noopener\">Definition lists</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#definition-lists\" aria-hidden=\"true\">#</a></h3>\n<p>Term 1</p>\n<p>: Definition 1\nwith lazy continuation.</p>\n<p>Term 2 with <em>inline markup</em></p>\n<p>: Definition 2</p>\n<p>{ some code, part of Definition 2 }</p>\n<p>Third paragraph of definition 2.</p>\n<p><em>Compact style:</em></p>\n<p>Term 1\n~ Definition 1</p>\n<p>Term 2\n~ Definition 2a\n~ Definition 2b</p>\n<h3 id=\"abbreviations\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-abbr\" target=\"_blank\" rel=\"noopener\">Abbreviations</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#abbreviations\" aria-hidden=\"true\">#</a></h3>\n<p>This is HTML abbreviation example.</p>\n<p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p>\n<p>*[HTML]: Hyper Text Markup Language</p>\n<h3 id=\"custom-containers\" tabindex=\"-1\"><a href=\"https://github.com/markdown-it/markdown-it-container\" target=\"_blank\" rel=\"noopener\">Custom containers</a> <a class=\"direct-link\" href=\"https://rootaround.github.io/posts/drafts/test/#custom-containers\" aria-hidden=\"true\">#</a></h3>\n<p>::: warning\n<em>here be dragons</em>\n:::</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Footnote <strong>can have markup</strong></p>\n<p>and multiple paragraphs. <a href=\"https://rootaround.github.io/posts/drafts/test/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>Footnote text. <a href=\"https://rootaround.github.io/posts/drafts/test/#fnref2\" class=\"footnote-backref\">↩︎</a> <a href=\"https://rootaround.github.io/posts/drafts/test/#fnref2:1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>Text of inline footnote <a href=\"https://rootaround.github.io/posts/drafts/test/#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-25T20:12:00Z"
    },{
      "id": "https://rootaround.github.io/posts/wiki/javascript/",
      "url": "https://rootaround.github.io/posts/wiki/javascript/",
      "title": "javascript",
      "content_html": "",
      "date_published": "2021-07-24T00:00:00Z"
    },{
      "id": "https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/",
      "url": "https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/",
      "title": "Linux Tools: shells, ash #6 - environment variables",
      "content_html": "<p>Уже достаточно много раз говорили о переменных и environment-переменных , в этом разделе разберем встроенные переменные ash</p>\n<!-- more -->\n<p>Предыдущая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-6-ash-functions/\">shells, ash #5 - ash functions</a></p>\n<h2 id=\"home\" tabindex=\"-1\">HOME <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#home\" aria-hidden=\"true\">#</a></h2>\n<p>Домашняя директория пользователя и passwd файла, переменная устанавливается командой login и используется множеством разных команд, например, командой cd без параметров для перехода в домашнюю директорию пользователя</p>\n<p>Для проверки можно запустить ash без env-переменных от root пользователя и выполнить команду login</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">## запускаем ash без env-параметров текущего shell и под root</span>\n<span class=\"token comment\">## root - нужен для запуска login,</span>\n<span class=\"token comment\">## иначе будет ошибка login: must be suid to work properly</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">env</span> <span class=\"token parameter variable\">-i</span> /usr/bin/ash\n\n<span class=\"token comment\">## далее одинарная решетка это prompt root пользователя</span>\n<span class=\"token comment\"># env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n\n<span class=\"token comment\"># login -f ubuntu</span>\n<span class=\"token comment\">## ...</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/home/ubuntu/bin:/home/ubuntu/.local/bin:/data/bin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">USER</span></span><span class=\"token operator\">=</span>ubuntu\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">HOME</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token comment\">## ...</span></code></pre>\n<h2 id=\"path\" tabindex=\"-1\">PATH <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#path\" aria-hidden=\"true\">#</a></h2>\n<p>Список директорий разделенный двоеточиями</p>\n<p>В этих директориях shell ищет программы, подробнее процесс поиска мы рассмотрели <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-types-programs\">в статье с выполнением команд</a></p>\n<h2 id=\"cdpath\" tabindex=\"-1\">CDPATH <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#cdpath\" aria-hidden=\"true\">#</a></h2>\n<p>Путь относительно которого работает команда cd</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># задаем CDPATH=/home/ubuntu</span>\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">CDPATH</span><span class=\"token operator\">=</span>/home/ubuntu\n\n$ <span class=\"token builtin class-name\">cd</span>\n/home/ubuntu\n\n<span class=\"token comment\"># теперь все относительные пути без указания первого слэша</span>\n<span class=\"token comment\"># будут считаться относительно /home/ubuntu</span>\n$ <span class=\"token builtin class-name\">cd</span> tmp\n<span class=\"token comment\"># мы в /home/ubuntu/tmp - если такая директория существует</span></code></pre>\n<h2 id=\"mail\" tabindex=\"-1\">MAIL <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#mail\" aria-hidden=\"true\">#</a></h2>\n<p>Следующие 3 env-переменных нужны для проверки почты, точнее в самом shell реализовано слежение за изменением в файле</p>\n<p>в MAIL может содержаться путь к файлу, за изменениями которого нужно следить</p>\n<h2 id=\"mailcheck\" tabindex=\"-1\">MAILCHECK <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#mailcheck\" aria-hidden=\"true\">#</a></h2>\n<p>в MAILCHECK устанавливается время в секундах, через сколько нужно проверять файл или файлы указанные в MAIL или MAILPATH</p>\n<p>По умолчанию = 60</p>\n<p>Если поставить 0, то проверка будет происходит после каждого выполнения команды, В доке формулируется так “If set to 0, the check will occur at each prompt”, то есть при каждом показе приглашения к вводу команды.</p>\n<h2 id=\"mailpath\" tabindex=\"-1\">MAILPATH <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#mailpath\" aria-hidden=\"true\">#</a></h2>\n<p>в MAILPATH через двоеточие <code>:</code> может быть указано несколько файлов, которые нужно проверять</p>\n<p>если указан MAILPATH, то MAIL игнорируется.</p>\n<p>работает это так</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">touch</span> ~/mail.txt\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">MAILPATH</span><span class=\"token operator\">=</span>/home/ubuntu/mail.txt\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">MAILCHECK</span></span><span class=\"token operator\">=</span><span class=\"token number\">5</span>\n\n<span class=\"token comment\"># меняем файл, в случае почтовых программ они меняют файл</span>\n<span class=\"token comment\"># и bash видимо умеет их парсить и выводить даже количество писем</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token operator\">>></span> ~/mail.txt\n\n<span class=\"token comment\"># далее после выполнения команды или просто пустой строки ash выведет</span>\n$\nyou have mail\n$\n<span class=\"token comment\"># то есть проверка происходит перед показом prompt</span></code></pre>\n<h2 id=\"ps1\" tabindex=\"-1\">PS1 <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#ps1\" aria-hidden=\"true\">#</a></h2>\n<p>Prompt String - это основная подсказка к вводу команды и по умолчанию для обычного пользователя это переменная равна <code>$ </code> (доллар и пробел), для суперпользователя root <code># </code> (решетка и пробел)</p>\n<p>значение может содержать не специальные последовательности</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># например, по умолчанию PS1 в ash выводит еще и текущую директорию</span>\n<span class=\"token comment\"># сейчас мы в домашней директории</span>\n~ $\n\n<span class=\"token comment\"># а переменная равна</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PS1</span>\n<span class=\"token punctuation\">\\</span>w <span class=\"token punctuation\">\\</span>$</code></pre>\n<p>Подробнее про эти опции поговорим в статьях про bash</p>\n<h2 id=\"ps2\" tabindex=\"-1\">PS2 <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#ps2\" aria-hidden=\"true\">#</a></h2>\n<p>Подсказка ввода для многострочных команд. По умолчанию <code>&gt; </code></p>\n<pre><code>$ (\n&gt; echo 123\n&gt; )\n123\n$\n</code></pre>\n<h2 id=\"ps3\" tabindex=\"-1\">PS3 <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#ps3\" aria-hidden=\"true\">#</a></h2>\n<p>Почему-то не описано в документации, возможно в ash не используется</p>\n<h2 id=\"ps4\" tabindex=\"-1\">PS4 <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#ps4\" aria-hidden=\"true\">#</a></h2>\n<p>В случае если включена трассировка опцией <code>-x</code>, перед каждой выполненной командой выводится значение PS4</p>\n<p>По умолчанию равно <code>+ </code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">set</span> <span class=\"token parameter variable\">-x</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n+ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token number\">1</span>\n+ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n<span class=\"token number\">2</span>\n$</code></pre>\n<h2 id=\"ifs\" tabindex=\"-1\"><a id=\"IFS\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#IFS\"></a> IFS <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#ifs\" aria-hidden=\"true\">#</a></h2>\n<p>Input Field Separators</p>\n<p>Разделители при чтении и выводе параметров - подробнее разберем в следующей статье про Special Parameters (здесь будет ссылка на статью)</p>\n<h2 id=\"term\" tabindex=\"-1\">TERM <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#term\" aria-hidden=\"true\">#</a></h2>\n<p>В переменной содержится название текущего терминала, и используется программами для определения возможностей терминала, например, программа может определить поддерживает ли терминал цвета (xterm или xterm-256color)</p>\n<h2 id=\"histsize\" tabindex=\"-1\">HISTSIZE <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#histsize\" aria-hidden=\"true\">#</a></h2>\n<p>Сколько команд хранить в истории shell’a (это переключение истории команд стрелками)</p>\n<p>По умолчанию равно 15</p>\n<h2 id=\"pwd\" tabindex=\"-1\">PWD <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#pwd\" aria-hidden=\"true\">#</a></h2>\n<p>Текущая директория, эту переменную меняет команда cd</p>\n<h2 id=\"oldpwd\" tabindex=\"-1\">OLDPWD <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#oldpwd\" aria-hidden=\"true\">#</a></h2>\n<p>Предыдущая директория</p>\n<h2 id=\"ppid\" tabindex=\"-1\">PPID <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#ppid\" aria-hidden=\"true\">#</a></h2>\n<p>ID процесса текущего shell</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PPID</span>\n<span class=\"token number\">1527</span></code></pre>\n<p> </p>\n<h2 id=\"itogo\" tabindex=\"-1\">Итого <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#itogo\" aria-hidden=\"true\">#</a></h2>\n<p>В статье разобрали все возможные Environment Variables в ash, больше переменных и логики будет в bash</p>\n<p> </p>\n<p>Предыдущая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-6-ash-functions/\">shells, ash #5 - ash functions</a></p>\n<p> </p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-06-linux-tools-shells-ash-6-environment-variables/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li><a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/dash.1.html</a></li>\n<li><a href=\"https://man7.org/linux/man-pages/man1/login.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/login.1.html</a></li>\n<li><a href=\"https://github.com/mandober/enwars#mail\" target=\"_blank\" rel=\"noopener\">https://github.com/mandober/enwars#mail</a></li>\n<li><a href=\"https://unix.stackexchange.com/questions/528323/what-uses-the-term-variable\" target=\"_blank\" rel=\"noopener\">https://unix.stackexchange.com/questions/528323/what-uses-the-term-variable</a></li>\n</ul>\n<p> </p>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-tools\">Все статьи серии “Linux Tools”</a></p>\n",
      "date_published": "2021-06-16T20:00:00Z"
    },{
      "id": "https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/",
      "url": "https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/",
      "title": "Linux Tools: shells, ash #5 - ash syntax, functions",
      "content_html": "<p>В прошлой статье прошли по сложным командам, циклам и условиям. Теперь усложняем. Что если нужно выполнять много сложных команд и еще хочется переиспользовать некоторые части команд?</p>\n<!-- more -->\n<p>На помощь приходят функции</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function-name function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">command</span>\n  <span class=\"token punctuation\">..</span>.\n  <span class=\"token builtin class-name\">return</span> <span class=\"token punctuation\">[</span>exitstatus<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Функции могут содержать всего одну команду и записываться без фигурных скобок</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ hello<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span>\n$ hello\nHello</code></pre>\n<p>Или несколько команд</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span>\n<span class=\"token punctuation\">}</span>\n$ hello\nHello\nWorld</code></pre>\n<p>Каждая функция работает как обычная команда-программа и возвращает exit-код. По умолчанию возвращается 0, но можно вернуть нужный exit-код c помощью return. При этом выполнение функции прекращается на return.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span>\n<span class=\"token builtin class-name\">return</span> <span class=\"token number\">100</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># World не выводится</span>\n$ hello\nHello\n\n<span class=\"token comment\"># $? содержит exit-код предыдущей команды</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">100</span></code></pre>\n<h2 id=\"parametry-i-peremennye\" tabindex=\"-1\"><a id=\"parameters-variables\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#parameters-variables\"></a> Параметры и переменные <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#parametry-i-peremennye\" aria-hidden=\"true\">#</a></h2>\n<p>В 3 статье серии мы уже немного <a href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#variables\">говорили о переменных</a>, сегодня разберемся с ними подробно.</p>\n<p>Параметры (Parameters) могут позиционными и специальными, а параметры с именем называются переменными (Variables).</p>\n<h3 id=\"poziczionnye-parametry-positional-parameters\" tabindex=\"-1\"><a id=\"postional-parameters\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#postional-parameters\"></a> Позиционные параметры - Positional Parameters <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#poziczionnye-parametry-positional-parameters\" aria-hidden=\"true\">#</a></h3>\n<p>При запуске скрипта все параметры перечисленные после команды являются позиционными параметрами и ash позволяет обращаться к ним по номерам, начиная с 1.</p>\n<p>В параметре <code>$0</code> хранится путь к текущему скрипту или путь к shell, если запущен интерактивный режим</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># параметр $0 самого shell хранит путь к shell-программе</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$0</span>\n/usr/bin/ash\n\n$ <span class=\"token function\">cat</span> ./test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$0='</span><span class=\"token variable\">$0</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$1='</span><span class=\"token variable\">$1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$2='</span><span class=\"token variable\">$2</span>\n\n<span class=\"token comment\"># передаем пару параметров скрипту test.sh</span>\n$ ash ./test.sh first second\n<span class=\"token variable\">$0</span><span class=\"token operator\">=</span>./test.sh\n<span class=\"token variable\">$1</span><span class=\"token operator\">=</span>first\n<span class=\"token variable\">$2</span><span class=\"token operator\">=</span>second</code></pre>\n<p>Точно такая же логика с позиционными параметрами работает и для функций. В <code>$0</code> будет содержаться путь к shell, а параметры в функции можно передавать аналогично скриптам</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$0='</span><span class=\"token variable\">$0</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n$ hello World\n<span class=\"token variable\">$0</span><span class=\"token operator\">=</span>/usr/bin/ash\nHello, World</code></pre>\n<p>Позиционные параметры в скриптах и функциях можно переопределять с помощью builtin-команды <code>set</code> (подробно синтаксис set разберем в отдельной статье про builtin-команды)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span> and <span class=\"token variable\">$2</span>\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin class-name\">set</span> Beavis Butthead<span class=\"token punctuation\">;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span> and <span class=\"token variable\">$2</span>\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n$ hello Rick Morty\nHello, Rick and Morty\nHello, Beavis and Butthead</code></pre>\n<h3 id=\"peremennye-variables\" tabindex=\"-1\"><a id=\"variables\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#variables\"></a> Переменные - Variables <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#peremennye-variables\" aria-hidden=\"true\">#</a></h3>\n<p>Shell-переменные можно использовать внутри скриптов для хранения значений</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n$ <span class=\"token assign-left variable\">b</span><span class=\"token operator\">=</span><span class=\"token number\">2</span>\n$ <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$a</span>-<span class=\"token variable\">$b</span>-<span class=\"token variable\">$TEST</span>\"</span>\n<span class=\"token number\">1</span>-2-100500</code></pre>\n<p>Но эти параметры не передаются при вызовах команд в environment-переменные, можно делать вручную задавать environment-переменные для каждой команды</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> ./test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'$TEST='</span><span class=\"token variable\">$TEST</span>\n\n<span class=\"token comment\"># переменная TEST будет пуста</span>\n$ ./test.sh\n<span class=\"token variable\">$TEST</span><span class=\"token operator\">=</span>\n\n<span class=\"token comment\"># передаем значение переменной TEST на момент вызова</span>\n$ <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> ./test.sh\n<span class=\"token variable\">$TEST</span><span class=\"token operator\">=</span><span class=\"token number\">1</span></code></pre>\n<p>Для того чтобы shell-переменные передавались в окружение (environment) всем выполняемым командам, нужно экспортировать переменную</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span>\n\n$ ./test.sh\n<span class=\"token variable\">$TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span></code></pre>\n<h3 id=\"peremennye-v-funkcziyah\" tabindex=\"-1\"><a id=\"function-variables\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#function-variables\"></a> Переменные в функциях <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#peremennye-v-funkcziyah\" aria-hidden=\"true\">#</a></h3>\n<p>В функциях видны все shell-переменные (и environment-переменные тоже) — их можно использовать внутри.</p>\n<p>Также все команды, выполненные внутри функций влияют на shell, в общем все точно также как и при выполнении обычных команд без функции. Чтобы команды не влияли на текущий shell можно <a href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#grouping-parentheses\">группировать их в круглых скобках </a>.</p>\n<h3 id=\"lokalnye-peremennye-v-funkcziyah\" tabindex=\"-1\"><a id=\"local-function-variables\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#local-function-variables\"></a> Локальные переменные в функциях <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#lokalnye-peremennye-v-funkcziyah\" aria-hidden=\"true\">#</a></h3>\n<p>Если определенные переменные нужны только внутри функции можно воспользоваться builtin-функцией local.</p>\n<p>Команда <code>local</code> должна быть вызвана в начале функции и должна содержать имя локальной переменной. Локальные переменные никак не инициализируются и задавать значения им нужно отдельно.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># в shell своя переменная name</span>\n$ <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino\n\n$ <span class=\"token function-name function\">hello</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">local</span> name <span class=\"token comment\"># в функции своя переменная name</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'local name='</span><span class=\"token variable\">$name</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'local name='</span><span class=\"token variable\">$name</span>\n<span class=\"token punctuation\">}</span>\n\n$ hello\n<span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino\n<span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n\n<span class=\"token comment\"># в shell переменная не поменялась</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'name='</span><span class=\"token variable\">$name</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino</code></pre>\n<p>Кроме этого scope локальных переменных сохраняется при создании вложенных функций - то есть для вложенной функции будет своя переменная, а не глобальная.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>Pachino\n\n$ <span class=\"token function-name function\">hello</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">local</span> name\n  <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'name='</span><span class=\"token variable\">$name</span>\n\n  <span class=\"token function-name function\">bang</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'bang name='</span><span class=\"token variable\">$name</span> <span class=\"token punctuation\">}</span>\n\n  bang\n<span class=\"token punctuation\">}</span>\n\n\n$ hello\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n<span class=\"token comment\"># в функции bang переиспользуется локальная переменная name</span>\n<span class=\"token comment\"># из функции hello</span>\nbang <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span>DeNiro\n\n<span class=\"token comment\"># в shell осталась своя переменная</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$name</span>\nPachino</code></pre>\n<p>Вместо имени переменной в <code>local</code> можно указать <code>-</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token builtin class-name\">local</span> -\n<span class=\"token comment\"># ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>В этом случае все установленные опции с помощью команды <code>set</code> будут локальными и вернуться к своим значениям при выходе из функции. Про установку опций с помощью <code>set</code> говорили во <a href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#xtrace-arg-adv\">2 статье серии</a>.</p>\n<h2 id=\"potoki-v-funkcziyah\" tabindex=\"-1\"><a id=\"function-streams\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#function-streams\"></a> Потоки в функциях <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#potoki-v-funkcziyah\" aria-hidden=\"true\">#</a></h2>\n<p>Раз функция ведет себя как команда, значит внутри нее можно работать с потоками и использовать функции в пайплайнах</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># передаем в cat данные из stdin-потока</span>\n$ hello <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span> <span class=\"token function\">cat</span> <span class=\"token operator\">&lt;</span><span class=\"token file-descriptor important\">&amp;0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span> <span class=\"token operator\">|</span> hello\nHello\nWorld</code></pre>\n<p>stdout и stderr- потоки у функции также свои</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function-name function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'World'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n$ hello\nHello\nWorld\n\n<span class=\"token comment\"># перенаправляем stderr в /dev/null</span>\n$ hello <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>/dev/null\nHello</code></pre>\n<p> </p>\n<h1 id=\"itogo\" tabindex=\"-1\">Итого <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#itogo\" aria-hidden=\"true\">#</a></h1>\n<p>Сегодня узнали как создавать shell-функции и как использовать параметры, потоки и переменные внутри shell-функций.</p>\n<p>Основной функционал ash мы рассмотрели, но существует несколько возможностей, которые делают написание скриптов еще удобнее – их и обсудим в следующей статье.</p>\n<p> </p>\n<p>Предыдущая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-5-ash-complex-commands/\">shells, ash #4 - ash syntax, complex commands, pipelines, conditions and loops</a></p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-06-linux-tools-shells-ash-6-environment-variables/\">shells, ash #6 - environment variables</a></p>\n<p> </p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-6-ash-functions/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li><a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/dash.1.html</a></li>\n</ul>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-tools\">Все статьи серии “Linux Tools”</a></p>\n",
      "date_published": "2021-01-20T19:03:00Z"
    },{
      "id": "https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/",
      "url": "https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/",
      "title": "Linux Tools: shells, ash #4 - ash syntax, complex commands, pipelines, conditions and loops",
      "content_html": "<p>В предыдущей статье изучили как работает перенаправление потоков, сегодня начнем разбираться как выполнять комбинации команд, но сперва обсудим какие могут быть команды.</p>\n<!-- more -->\n<p>Предыдущая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-4-ash-redirections/\">shells, ash #3 - ash syntax, redirections</a></p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-6-ash-functions/\">shells, ash #5 - ash syntax, functions\n</a></p>\n<h1 id=\"tipy-komand\" tabindex=\"-1\"><a id=\"command-types\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-types\"></a> Типы команд <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#tipy-komand\" aria-hidden=\"true\">#</a></h1>\n<p>В ash существуют 3 типа команд: shell-функции, buildin-команды и программы. При выполнении осуществляется поиск команды именно в таком порядке.</p>\n<h2 id=\"vypolnenie-shell-funkczij\" tabindex=\"-1\"><a id=\"command-types-shell-functions\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-types-shell-functions\"></a> Выполнение shell-функций <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#vypolnenie-shell-funkczij\" aria-hidden=\"true\">#</a></h2>\n<p>Все аргументы переданные с вызовом функции, передаются в функцию. Все environment-переменные также доступны внутри функции. Сама функция выполняется в текущем шелле.\nСейчас важно то что функции также как можно использовать также как и команды-программы и builtin-функции, то есть создавать комбинации из функций и команд.</p>\n<p>Функции рассмотрим в следующих статьях. Сейчас небольшой пример использования</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ hello <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$1</span>\"</span>\n<span class=\"token comment\"># stdout можно перенаправить</span>\n$ hello Kenneth <span class=\"token operator\">></span> ./tmp.txt\n<span class=\"token comment\"># или использовать в пайплайнах</span>\n<span class=\"token comment\">#  - пайплайны разберем в этой статье</span>\n$ hello Kenneth <span class=\"token operator\">|</span> <span class=\"token function\">cat</span>\nhello, Kenneth</code></pre>\n<h2 id=\"vypolnenie-builtin-komand\" tabindex=\"-1\"><a id=\"command-types-builtin\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-types-builtin\"></a> Выполнение builtin-команд <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#vypolnenie-builtin-komand\" aria-hidden=\"true\">#</a></h2>\n<p>builtin-команды выполняются внутри текущего shell, без запуска отдельного процесса.\nbuiltin-команды в ash также разберем отдельной статьей, их достаточно много, но в общем некоторые общие команды такие как <code>echo</code>, <code>ls</code> и другие могут быть встроены в shell.</p>\n<h2 id=\"vypolnenie-komand-programm\" tabindex=\"-1\"><a id=\"command-types-programs\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-types-programs\"></a> Выполнение команд-программ <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#vypolnenie-komand-programm\" aria-hidden=\"true\">#</a></h2>\n<p>Если имя команды не является shell-функцией или builtin-командой, значит это программа в файловой системе и ее нужно найти и выполнить.</p>\n<p>Если имя команды содержит слэш <code>/</code>, то команда сразу выполняется без поиска в файловой системе – имя команды используется как путь к программе</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ /usr/bin/htop\n<span class=\"token comment\"># команда запуститься сразу</span></code></pre>\n<p>Если слэшей в имени команды нет, то происходит поиск файла программы по имени в директориях из environment-переменной PATH.</p>\n<p>В переменной PATH содержится список директорий разделенных двоеточием <code>:</code>, конечно же переменную PATH можно изменить, установить свой список директорий или дополнить существующий.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/sbin:/usr/sbin:/bin:/usr/bin\n\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token environment constant\">$PATH</span>:/home/ubuntu/bin\n\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/sbin:/usr/sbin:/bin:/usr/bin:/home/ubuntu/bin</code></pre>\n<p>Текущая директория (PWD) тоже может содержаться в PATH, для этого нужно указать пустую строку между двоеточиями или в конце</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># в конце строки</span>\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/bin:\n\n<span class=\"token comment\"># пустая директория</span>\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/bin::\n\n<span class=\"token comment\"># в начале строки</span>\n$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>:/sbin:/bin</code></pre>\n<p>Для выполнения будет использована первая найденная команда, то есть порядок директорий важен.</p>\n<p>Если команда не существует ни в одной директории, получим ошибку not found</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ noop\n/usr/bin/ash: noop: not found</code></pre>\n<h1 id=\"vypolnenie-komand-programm-1\" tabindex=\"-1\"><a id=\"command-exec\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-exec\"></a> Выполнение команд-программ <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#vypolnenie-komand-programm-1\" aria-hidden=\"true\">#</a></h1>\n<p>Когда команда найдена начинается ее выполнение и тут снова возможно несколько сценариев:</p>\n<h2 id=\"magic-number\" tabindex=\"-1\"><a id=\"command-exec-magic-number\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-exec-magic-number\"></a> magic_number <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#magic-number\" aria-hidden=\"true\">#</a></h2>\n<p>исполняемый файл-программа начинается с magic number. Тут имеется ввиду ELF-заголовок по которому определяется что программа может выполняться и дальше при выполнении происходит чтение из этого файла используя ELF-формат.</p>\n<p>В этом случае создается новый процесс, которому переданы все аргументы команды и переменные окружения.</p>\n<h2 id=\"shebang\" tabindex=\"-1\"><a id=\"command-exec-shebang\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#command-exec-shebang\"></a> shebang <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#shebang\" aria-hidden=\"true\">#</a></h2>\n<p>Если программа не имеет ELF-заголовка, но начинается с <code>#!</code> программа выполняется как отдельный shell. Причем после <code>#!</code> указывается интрепретатор и один аргумент</p>\n<p>Ситаксис</p>\n<pre><code>#!interprer [optional-arg]\n</code></pre>\n<p>Пример</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/usr/bin/ash</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span></code></pre>\n<p>Скрипт выше будет выполнен интерпертатором ash. Кроме shell таком образом могут выполняться программы на интерпретируемых языках программирования, например, python или php</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/usr/bin/python</span>\nprint<span class=\"token punctuation\">(</span><span class=\"token string\">'123'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Для того чтобы выполнить скрипт как программу нужно чтобы для файла был установлен атрибут eXecutable</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">chmod</span> +x ./test.sh\n$ ./test.sh\n<span class=\"token number\">123</span></code></pre>\n<h2 id=\"exit-status\" tabindex=\"-1\"><a id=\"exit-status\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#exit-status\"></a> Exit status <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#exit-status\" aria-hidden=\"true\">#</a></h2>\n<p>В Linux каждый процесс завершается с определенным числовым статусом, exit-статусом или exit-кодом.</p>\n<p>Если exit-код равен 0 — программа выполнена успешно, другие значения означают ошибку.\nУ каждой команды свой список exit-кодов и их значение можно посмотреть в документации (man) команды.</p>\n<p>Builtin-команды и shell-функции также возвращают exit-коды.</p>\n<p>Забегая немного вперед - exit-код последней выполненной команды можно посмотреть с помощью специальной shell-переменной <code>$?</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">env</span>\n<span class=\"token comment\"># ...</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">0</span></code></pre>\n<p>В случае списков команд итоговым будет exit-код последней команды.</p>\n<h1 id=\"complex-commands\" tabindex=\"-1\"><a id=\"complex-commands\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#complex-commands\"></a> Complex Commands <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#complex-commands\" aria-hidden=\"true\">#</a></h1>\n<p>Все предыдущие разделы были необходимой подготовкой к пониманию более сложных конструкций из команд.</p>\n<p>Итак команды могут быть одним из следующих:</p>\n<ul>\n<li>простой командой (simple command)</li>\n<li>пайплайном (pipeline)</li>\n<li>списком команд (list)</li>\n<li>составной командой (compound command)</li>\n<li>определением функции (function definition)</li>\n</ul>\n<h1 id=\"pipelines\" tabindex=\"-1\"><a id=\"complex-commands-pipelines\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#complex-commands-pipelines\"></a> Pipelines <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#pipelines\" aria-hidden=\"true\">#</a></h1>\n<p>Pipeline - последовательность команд разделенных управляющим оператором <code>|</code>.</p>\n<p>Stdout каждой команды перенаправляется в stdin следующей команды, а для последней команды stdout работает как обычно. Как итоговый exit-код используется exit-код последней команды.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> abc <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span>\na</code></pre>\n<p>В примере выше stdout команды <code>echo abc</code> передается в stdin команды <code>head</code>, которая берет из своего stdin только один символ.</p>\n<p>Для примера с exit-кодом не будем передавать значение аргумента <code>-c</code>, в этом случае команда <code>head</code> завершается с ошибкой</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> abc <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ... сообщение об ошибке</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">1</span>  <span class=\"token comment\"># &lt;&lt;&lt; команда завершилась с ошибкой</span></code></pre>\n<p>Exit-код пайплайна можно инвертировать, если добавить перед пайплайном восклицательный знак <code>!</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token operator\">!</span> <span class=\"token builtin class-name\">echo</span> abc <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ... сообщение об ошибке</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">0</span></code></pre>\n<p>Для каждой команды можно использовать операторы перенаправления. Для примера возьмем вывод команды <code>head -c</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">|</span> <span class=\"token function\">cat</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<p><code>head -c</code> передает stdout команде <code>cat</code>, а уже stdout команды <code>cat</code> выводится в терминал</p>\n<p>Если перенаправить результат cat в /dev/null …</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">|</span> <span class=\"token function\">cat</span> <span class=\"token operator\">></span> /dev/null\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<p>… то ничего не поменяется, потому что текст ошибки выводится в stderr-поток, тут мы можем использовать перенаправление — перенаправляем stderr в stdout — в итоге и stderr и stdout команды <code>head</code> попадают в stdin команды <code>cat</code>, а потом в /dev/null</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span> <span class=\"token operator\">|</span> <span class=\"token function\">cat</span> <span class=\"token operator\">></span> /dev/null</code></pre>\n<h1 id=\"spiski-lists\" tabindex=\"-1\"><a id=\"lists\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#lists\"></a> Списки - Lists <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#spiski-lists\" aria-hidden=\"true\">#</a></h1>\n<p>Для последовательного выполнения команд без перенаправления потоков существуют списки команд.</p>\n<h2 id=\"simple-list\" tabindex=\"-1\"><a id=\"simple-lists\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#simple-lists\"></a> Simple List - <code>;</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#simple-list\" aria-hidden=\"true\">#</a></h2>\n<p>Самы простой вариант составить список без связи команд это использовать между командами <code>;</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Команды будут выполнены последовательно одна за другой в указанном порядке, при этом даже если первая команда завершится с ненулевым exit-кодом, остальные все равно будут выполнены.</p>\n<h2 id=\"and-list-and-and\" tabindex=\"-1\"><a id=\"and-lists\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#and-lists\"></a> AND-List - <code>&amp;&amp;</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#and-list-and-and\" aria-hidden=\"true\">#</a></h2>\n<p>Для того чтобы команды выполнялись только в случае успешного завершения предыдущей команды используют оператор <code>&amp;&amp;</code>.</p>\n<p>В этом случае следующая команда будет выполнена только если предыдущая завершилась с exit-кодом равным 0.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># есть текстовый файл abc.txt, в котором содержатся 3 символа 'abc'</span>\n$ <span class=\"token function\">cat</span> abc.txt\nabc\n\n<span class=\"token comment\"># составляем список команд команд:</span>\n<span class=\"token comment\"># - head читает один символ из файла</span>\n<span class=\"token comment\"># - echo выводит '- first char in file'</span>\n<span class=\"token comment\">#   если предыдущая команда завершилась успешно</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">' - first char in file'</span>\na - first char <span class=\"token keyword\">in</span> <span class=\"token function\">file</span>\n\n<span class=\"token comment\"># head выполнилась успешно и затем выполнилась команда echo</span>\n\n<span class=\"token comment\"># если убрать число символов в команде head - возникнет ошибка -</span>\n<span class=\"token comment\"># head завершится с exit-кодом 1 и echo не будет выполнено</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">' - first char in file'</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<h2 id=\"or-list\" tabindex=\"-1\"><a id=\"or-lists\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#or-lists\"></a> OR-List - <code>||</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#or-list\" aria-hidden=\"true\">#</a></h2>\n<p>В OR-List команда следующая за оператором <code>||</code> выполняется только если exit-код предыдущей команды больше 0.</p>\n<p>Возьмем последнюю команду из предыдущего примера и немного изменим</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># убираем значение аргумента -с</span>\n<span class=\"token comment\"># меняем &amp;&amp; на ||</span>\n<span class=\"token comment\"># меняем текст сообщения</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'it is failed'</span>\nhead: option requires an argument -- <span class=\"token string\">'c'</span>\n<span class=\"token comment\"># ...</span>\nit is failed\n\n<span class=\"token comment\"># echo выполнилось потому что exit-код первой команды больше 0</span>\n\n<span class=\"token comment\"># если исправить первую команду - echo перестанет выполняться</span>\n$ <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span>abc.txt <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'it is failed'</span>\na</code></pre>\n<h1 id=\"gruppirovka-spiskov-komand\" tabindex=\"-1\"><a id=\"grouping\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#grouping\"></a> Группировка списков команд <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#gruppirovka-spiskov-komand\" aria-hidden=\"true\">#</a></h1>\n<p>Команды могут быть сгруппированы двумя способами:</p>\n<h2 id=\"pervyj-ispolzuya-kruglye-skobki\" tabindex=\"-1\"><a id=\"grouping-parentheses\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#grouping-parentheses\"></a> Первый - используя круглые скобки <code>()</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#pervyj-ispolzuya-kruglye-skobki\" aria-hidden=\"true\">#</a></h2>\n<p>В этом случае команды будут выполнены в отдельном shell и команды не будут влиять на текущий shell</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token punctuation\">(</span>echo <span class=\"token string\">'abc'</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\na\n\n$ <span class=\"token punctuation\">(</span>export <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># переменная TEST не появится в текущем shell</span></code></pre>\n<h2 id=\"vtoroj-sposob-figurnye-skobki\" tabindex=\"-1\"><a id=\"grouping-curly\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#grouping-curly\"></a> Второй способ - фигурные скобки - <code>{}</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#vtoroj-sposob-figurnye-skobki\" aria-hidden=\"true\">#</a></h2>\n<p>Этот способ также как и первый позволяет сгруппировать stdout списка команд, как будто это одна команда, но команды выполняются в текущем shell.</p>\n<p>Первое обязательное условие этого способа - это наличие пробелов после первой и перед второй фигурными скобок.\nВторым обязательным условием является наличие точки с запятой <code>;</code> перед второй, завершающей скобкой <code>}</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">2</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token comment\"># также можно использовать другие списки, пайплайны</span>\n$ <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'abc'</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\na</code></pre>\n<h1 id=\"uslovnye-konstrukczii-i-czikly\" tabindex=\"-1\"><a id=\"conditions-and-loops\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#conditions-and-loops\"></a> Условные конструкции и циклы <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#uslovnye-konstrukczii-i-czikly\" aria-hidden=\"true\">#</a></h1>\n<p>С этого момента простое выполнение команд начинает превращаться в shell-программирование 😃</p>\n<h2 id=\"if-then\" tabindex=\"-1\"><a id=\"if\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#if\"></a> if … then <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#if-then\" aria-hidden=\"true\">#</a></h2>\n<p>Синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> list\n<span class=\"token keyword\">then</span> list\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">elif</span> list\n<span class=\"token keyword\">then</span>    list <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">..</span>.\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">else</span> list <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>Если list в <code>if</code> завершается с exit-кодом 0 - выполняется первый <code>then list</code>, а если exit-код больше 0 и есть <code>else list</code> - то будет выполнен он, аналогично для <code>elif .. then</code>.</p>\n<p>Все что после if, then, else, elif является просто списками команд.</p>\n<p>Единственным условием является разделение списка команд от служебных слов с помощью переноса строки, либо точкой с запятой <code>;</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">fi</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n\n<span class=\"token comment\"># то же самое в одну строку</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">fi</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n\n<span class=\"token comment\"># чуть более сложно выглядящий пример</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">fi</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">3</span>\n\n<span class=\"token comment\"># первый список команд завершается с exit-кодом больше 0</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token function\">ls</span> /nowhere <span class=\"token operator\">></span>/dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">else</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'bad'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">fi</span>\nbad\n<span class=\"token comment\"># выполнился else</span></code></pre>\n<p>В примерах мы видим stdout всех выполняющихся команд. Если значения stdout или stderr не нужны - их нужно перенаправлять в файлы или в /dev/null.</p>\n<p>После описания синтаксиса и примеров может возникнуть вопрос про условия в квадратных скобках</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span>\n$ <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$TEST</span> <span class=\"token operator\">==</span> <span class=\"token string\">'100'</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n<span class=\"token keyword\">else</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'bad'</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>Разве квадратные скобки не являются частью синтаксиса?</p>\n<p>Нет, не являются. И это одна из “магических” штук, которые с ходу кажутся простыми, но в итоге могут работать не так как ожидаешь.</p>\n<p>Оказывается открывающяя скобка <code>[</code> это команда <code>test</code>.</p>\n<p>Документация по <code>man [</code> и <code>man test</code> будет содержать одинаковую информацию.</p>\n<p>Если поискать такую команду с помощью <code>which</code> (which определяет где хранится команда на файловой системе используя PATH)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">which</span> <span class=\"token punctuation\">[</span>\n/usr/bin/<span class=\"token punctuation\">[</span></code></pre>\n<p>Закрывающая скобка <code>]</code> является обязательным завершающим аргументом для команды <code>[</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token punctuation\">[</span>\nash: missing <span class=\"token punctuation\">]</span></code></pre>\n<p>Конкретно в случае ash команды <code>[</code>, <code>test</code> и некоторые другие являются builtin-командами, мы разберем их через пару статей этой серии.</p>\n<p>Теперь <code>if</code> конструкция с квадратными скобками …</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$TEST</span> <span class=\"token operator\">==</span> <span class=\"token string\">'100'</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>… просто преобразуется в список из одной команды</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> <span class=\"token variable\">$TEST</span> <span class=\"token operator\">==</span> <span class=\"token string\">'100'</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>и точка с запятой в конце нужна чтобы разделить аргументы команды <code>test</code> от служебного слова <code>then</code></p>\n<h2 id=\"while\" tabindex=\"-1\"><a id=\"while\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#while\"></a> while <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#while\" aria-hidden=\"true\">#</a></h2>\n<p>C циклом <code>while</code> все еще проще чем <code>if</code></p>\n<p>Синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> list\n<span class=\"token keyword\">do</span> list\n<span class=\"token keyword\">done</span></code></pre>\n<p>Пока список команд после <code>while</code> завершается с exit-code равным 0 выполняется список команд после <code>do</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span>.txt\n$ <span class=\"token keyword\">while</span> <span class=\"token function\">cat</span> <span class=\"token number\">1</span>.txt <span class=\"token operator\">></span>/dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'has file'</span> <span class=\"token punctuation\">;</span> <span class=\"token function\">rm</span> <span class=\"token number\">1</span>.txt\n<span class=\"token keyword\">done</span>\nhas <span class=\"token function\">file</span>\n\n<span class=\"token comment\"># has file - выводится один раз и после этого следует выход из цикла</span></code></pre>\n<h2 id=\"until\" tabindex=\"-1\"><a id=\"until\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#until\"></a> until <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#until\" aria-hidden=\"true\">#</a></h2>\n<p><code>until</code> работает аналогично <code>while</code>, только цикл выполняется пока exit-код первого списка команд <strong>не равен</strong> 0.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># пока нет файла 2.txt цикл будет работать</span>\n$ <span class=\"token keyword\">until</span> <span class=\"token function\">cat</span> <span class=\"token number\">2</span>.txt <span class=\"token operator\">></span>/dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'has no file'</span> <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token operator\">></span> <span class=\"token number\">2</span>.txt <span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">done</span>\n\nhas no <span class=\"token function\">file</span></code></pre>\n<h2 id=\"for\" tabindex=\"-1\"><a id=\"for\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#for\"></a> for <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#for\" aria-hidden=\"true\">#</a></h2>\n<p>Ситаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> variable <span class=\"token punctuation\">[</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span> word <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>   list\n<span class=\"token keyword\">done</span></code></pre>\n<p>Цикл <code>for</code> позволяет перебирать список слов и на каждом шаге что-то выполнять с элементом</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"i = <span class=\"token variable\">$i</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span>\ni <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\ni <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\ni <span class=\"token operator\">=</span> <span class=\"token number\">3</span></code></pre>\n<p>С возможность подстановки результата команды (command substitution) - <code>$(command)</code> - цикл <code>for</code> позволяет перебирать все что угодно. Command substitution и другие полезные возможности рассмотрим в следующей статье.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># команда ls выдает список файлов в текущей директории</span>\n<span class=\"token comment\"># выдает в строку разделенные пробелами</span>\n$ <span class=\"token function\">ls</span>\n<span class=\"token number\">1</span>.txt <span class=\"token number\">2</span>.txt <span class=\"token number\">3</span>.txt\n\n<span class=\"token comment\"># используя for и command substitution</span>\n<span class=\"token comment\"># можем перебрать в цикле список файлов</span>\n$ <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"file = <span class=\"token variable\">$file</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span>\n<span class=\"token function\">file</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>.txt\n<span class=\"token function\">file</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span>.txt\n<span class=\"token function\">file</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>.txt</code></pre>\n<h2 id=\"break-continue\" tabindex=\"-1\"><a id=\"break-continue\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#break-continue\"></a> break, continue <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#break-continue\" aria-hidden=\"true\">#</a></h2>\n<p>синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n<span class=\"token builtin class-name\">continue</span> <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre>\n<ul>\n<li><code>break</code> - прерывает цикл <code>for</code> или <code>while</code> (<code>until</code>)</li>\n<li><code>continue</code> - переход на следующую итерацию цикла</li>\n</ul>\n<p>Если есть вложенные циклы, то можно указывая n применять <code>break</code> или <code>continue</code> для нескольких циклов</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">do</span> <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">j</span> <span class=\"token keyword\">in</span> a b c<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$i</span> - <span class=\"token variable\">$j</span>\"</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">break</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">done</span>\n<span class=\"token operator\">></span> <span class=\"token keyword\">done</span>\n<span class=\"token number\">1</span> - a\n<span class=\"token number\">2</span> - a\n<span class=\"token number\">3</span> - a\n<span class=\"token comment\"># каждый раз второй цикл будет прерываться на первой итерации</span>\n<span class=\"token comment\"># если поменять на break 2 то будет выведено только 1 - a</span></code></pre>\n<h2 id=\"case\" tabindex=\"-1\"><a id=\"case\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#case\"></a> case <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#case\" aria-hidden=\"true\">#</a></h2>\n<p>Синтаксис</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">case</span> word <span class=\"token keyword\">in</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">]</span>pattern<span class=\"token punctuation\">)</span> list <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">..</span>.\n<span class=\"token keyword\">esac</span></code></pre>\n<p>Проверяет соответствие word одному или нескольким паттернам, выполняется список команд у паттерна, который совпадает первым.</p>\n<p>завершающий <code>esac</code> это <code>case</code> наоборот, также как <code>if</code> и <code>fi</code>, кто-то придумал - так и осталось (или там какая-то другая история) 😃</p>\n<p>В самом простом виде в <code>case</code> можно выполнять команды или устанавливать переменные или и то и другое вместе</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">2</span>\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span>\n  <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'2'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p>Первую круглую скобку можно опустить. Кроме указания полных значений можно использовать Shell Patterns.</p>\n<p>Shell patterns позволяют указывать паттерны нестрогого соответствия для строк.</p>\n<p>В Shell Patterns могут использоваться мета-символы <code>! * ? [</code></p>\n<p><a id=\"case-asterisk\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#case-asterisk\"></a> <code>*</code> - соответвует любой последовательности символов, можно использовать как <code>case</code> по умолчанию.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n*<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'default'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p><a id=\"case-question\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#case-question\"></a> <code>?</code> - соответствует одному любому символу</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">1</span>??<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'100 or 1??'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p><a id=\"case-bracket\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#case-bracket\"></a> <code>[</code> - позволяет указать класс символов, внутри можно указать конкретные символы или диапазон символов, также можно комбинировать с другими мета-символами</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> a100\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>ab<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span>-9<span class=\"token punctuation\">]</span>*<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'ab1-9'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span></code></pre>\n<p>Cимволы <code>]</code> и <code>-</code> тоже можно использовать как символы внутри последовательности. Для этого символ <code>]</code> нужно разместить сразу после открывающей фигурной скобки <code>[</code> (но после <code>!</code>, если используется). Символ <code>-</code> нужно разместить первым или последним внутри класса символов.</p>\n<p><a id=\"case-excl-mark\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#case-excl-mark\"></a> <code>!</code> - используется внутри класса символов и означает <strong>несоответствие</strong> классу.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">i <span class=\"token operator\">=</span> a100\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$i</span> <span class=\"token keyword\">in</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token operator\">!</span>ab<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span>-9<span class=\"token punctuation\">]</span>*<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'c1-9'</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span>\n\n<span class=\"token comment\"># последний паттерн сработает и выведет c1-9 если i будет равно c100</span></code></pre>\n<p> </p>\n<h1 id=\"itogo\" tabindex=\"-1\">Итого <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#itogo\" aria-hidden=\"true\">#</a></h1>\n<p>В статье разобрались как выполняются команды, рассмотрели пайплайны, списки и группировку команд, возможности связать команды через AND-, OR- списки, условия и циклы. Вроде бы самый простой shell, но внутри еще достаточно много функционала для изучения.</p>\n<p>Дальше разберем функции и возможности работы с переменными.</p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-6-ash-functions/\">shells, ash #5 - ash syntax, functions\n</a></p>\n<p> </p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-5-ash-complex-commands/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li><a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/dash.1.html</a></li>\n<li><a href=\"https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format\" target=\"_blank\" rel=\"noopener\">https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format</a></li>\n<li><a href=\"https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix)\" target=\"_blank\" rel=\"noopener\">https://ru.wikipedia.org/wiki/Шебанг_(Unix)</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Exit_status\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Exit_status</a></li>\n</ul>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-tools\">Все статьи серии “Linux Tools”</a></p>\n",
      "date_published": "2021-01-13T08:00:00Z"
    },{
      "id": "https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/",
      "url": "https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/",
      "title": "Linux Tools: shells, ash #3 - ash syntax, redirections",
      "content_html": "<p>Продолжаем про ash и простые команды, сегодня разберемся с потоками и перенаправлением потоков процесса.</p>\n<!--more-->\n<p>Предыдущая статья: <a href=\"https://rootaround.github.io/posts/blog/2020-12-linux-tools-shells-part-3-ash-commands/\">shells, ash #2 - ash syntax, simple commands</a></p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-5-ash-complex-commands/\">shells, ash #4 - ash syntax, complex commands, pipelines, conditions and loops</a></p>\n<p>В одной из предыдущих статей я немного рассказал про потоки процесса и их нумерацию:</p>\n<ul>\n<li>0 - stdin - входной поток процесса, через него могут передаваться данные из другой команды</li>\n<li>1 - stdout - выходной поток процесса, в этот поток процесс может писать результаты</li>\n<li>2 - stderr - поток для ошибок и отладки</li>\n</ul>\n<p>Все перенаправления потоков, рассмотренные дальше, действуют только в рамках текущей команды или набора команд.</p>\n<h3 id=\"operator-n-file\" tabindex=\"-1\"><a id=\"operator-n-to-file\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-to-file\"></a> оператор <code>[n]&gt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-file\" aria-hidden=\"true\">#</a></h3>\n<p>Потоки можно перенаправлять в файлы</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 123 будет записано в файл</span>\n<span class=\"token comment\"># тут мы перенаправили поток stdout в файл tmp.txt</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">></span> tmp.txt</code></pre>\n<p>Оператор <code>&gt;</code> позволяет перенаправить поток в файл по номеру потока. Приведенная выше команда это краткая запись команды. Полная запись выглядит так</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># перенаправляем stdout в файл tmp.txt</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> tmp.txt</code></pre>\n<p>Аналогичным образом можно перенаправить stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'error'</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> errors.log</code></pre>\n<p>Оператор <code>&gt;</code> полностью перезаписывает содержимое файла новыми данными, если файл уже существует. Если файла нет - создает и записывает данные.</p>\n<p>Для защиты от перезаписи файлов, например, при отладке каких-то уже существующих скриптов, существует аргумент <code>-С</code> (<a href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noclobber-arg\">noclobber</a>), который предотвращает перезапись файла — с этим аргументом ash будет выдавать ошибку, если файл уже существует.</p>\n<h3 id=\"operator-n-file-1\" tabindex=\"-1\"><a id=\"operator-n-to-stick-file\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-to-stick-file\"></a> оператор <code>[n]&gt;| file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-file-1\" aria-hidden=\"true\">#</a></h3>\n<p>Делает все то же самое что и предыдущий оператор, но при запуске с аргументом <code>-C</code> (<a href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noclobber-arg\">noclobber</a>) файл все равно будет перезаписан — такой force для перенаправления потока в файл.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># скрипт записывает текст в файл с использованием оператора ></span>\n$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">></span> tmp.txt\n\n<span class=\"token comment\"># выполняем - в файл tmp.txt записывается 123</span>\n$ ash test.sh\n\n<span class=\"token comment\"># еще раз выполняем тот же скрипт,</span>\n<span class=\"token comment\"># файл tmp.txt будет перезаписан с тем же текстом 123</span>\n$ ash test.sh\n\n<span class=\"token comment\"># с аргументом -C при перенаправлении с оператором > будет ошибка</span>\n$ ash <span class=\"token parameter variable\">-C</span> test.sh\ntest.sh: line <span class=\"token number\">1</span>: can't create tmp.txt: File exists\n\n<span class=\"token comment\"># если переделать оператор > на >|</span>\n$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1234</span> <span class=\"token operator\">>|</span> tmp.txt\n\n<span class=\"token comment\"># то даже с аргументом -C файл будет перезаписан</span>\n$ ash <span class=\"token parameter variable\">-C</span> test.sh</code></pre>\n<h3 id=\"operator-n-file-2\" tabindex=\"-1\"><a id=\"operator-n-double-to-file\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-double-to-file\"></a> оператор <code>[n]&gt;&gt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-file-2\" aria-hidden=\"true\">#</a></h3>\n<p>Дописывает данные из потока в конец файла, если файла нет - то создает</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">567</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>>></span> tmp.txt\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">890</span> <span class=\"token operator\">>></span> tmp.txt\n$ <span class=\"token function\">cat</span> tmp.txt\n<span class=\"token number\">1234</span>\n<span class=\"token number\">567</span>\n<span class=\"token number\">890</span></code></pre>\n<h3 id=\"operator-n-file-3\" tabindex=\"-1\"><a id=\"operator-n-from-file\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-from-file\"></a> оператор <code>[n]&lt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-file-3\" aria-hidden=\"true\">#</a></h3>\n<p>чтение потока из файла</p>\n<p>В основном используется для чтения stdin</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># команда cat выводит stdin</span>\n<span class=\"token comment\"># или содержимое файла (если указан путь к файлу)</span>\n<span class=\"token comment\"># будет выведено содержимое stdin,</span>\n<span class=\"token comment\"># которое будет прочитано из файла tmp.txt</span>\n$ <span class=\"token function\">cat</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> tmp.txt\n<span class=\"token number\">1234</span>\n<span class=\"token number\">567</span>\n<span class=\"token number\">890</span>\n\n<span class=\"token comment\"># сокращенная запись без указания номера потока</span>\n$ <span class=\"token function\">cat</span> <span class=\"token operator\">&lt;</span> tmp.txt\n<span class=\"token comment\"># вывод такой же</span></code></pre>\n<p>Оператор перенаправления может быть записан и до команды</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token operator\">&lt;</span> tmp.txt <span class=\"token function\">cat</span>\n<span class=\"token comment\"># командой cat из stdin будет выведено содержимое файла tmp.txt</span></code></pre>\n<h3 id=\"operator-n1-and-n2\" tabindex=\"-1\"><a id=\"operator-n-to-descriptor\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-to-descriptor\"></a> оператор <code>[n1]&gt;&amp;n2</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n1-and-n2\" aria-hidden=\"true\">#</a></h3>\n<p>Перенаправляет поток n1 (или stdout - 1 по умолчанию) в поток с номером n2</p>\n<p>Интерактивный шелл тоже процесс и у него есть свои stdin, stdout, stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># пишем в stdout - поток с номером 1</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'out'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;1</span>\nout\n\n<span class=\"token comment\"># пишем в stderr - поток с номером 2</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'error'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span>\nerror</code></pre>\n<p>Вывод обеих команд будет отображен в консоли, потому что для интерактивного шелла весь вывод идет на экран.</p>\n<p>Для скриптов также можно писать отдельно в stdout и stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># скрипт пишет раздельно в stdout и в stderr</span>\n$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'out'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'error'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span>\n\n<span class=\"token comment\"># если просто выполнить скрипт, то всё увидим в консоли</span>\n$ ash test.sh\nout\nerror\n\n<span class=\"token comment\"># С помощью оператора ></span>\n<span class=\"token comment\"># мы можем перенаправить stdout и stderr в разные файлы</span>\n$ ash test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> stdout.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>stderr.txt\n$ <span class=\"token function\">cat</span> stdout.txt\nout\n$ <span class=\"token function\">cat</span> stderr.txt\nerror</code></pre>\n<p>Еще с помощью этого оператора можно наоборот сводить потоки, например, stdout и stderr в один файл</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> stdout.txt\nerror\n\n<span class=\"token comment\"># в консоли вывелось error,</span>\n<span class=\"token comment\"># потому что sterr не перенаправлен и отображается в консоль</span>\n\n<span class=\"token comment\"># заворачиваем поток stderr в stdout</span>\n$ ash test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> stdout.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n\n<span class=\"token comment\"># и stdout и stderr записались в файл stdout.txt</span>\n$ <span class=\"token function\">cat</span> stdout.txt\nout\nerror</code></pre>\n<h3 id=\"mnogostrochnye-dannye-dlya-potoka-here-document-heredoc\" tabindex=\"-1\"><a id=\"heredoc\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#heredoc\"></a> Многострочные данные для потока - here-document, heredoc <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#mnogostrochnye-dannye-dlya-potoka-here-document-heredoc\" aria-hidden=\"true\">#</a></h3>\n<p>Во всех примерах до этого мы рассмотрели перенаправления в файл и из файла. С помощью backslash(/) можно визуально переносить строки для лучшей читаемости и перенаправить их на вход другой команде (об этом в следующих статьях). Но при этом переносы строк не будут выводится</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"very very very \\\nlong long long \\\ntext text text\"</span>\nvery very very long long long text text text</code></pre>\n<p>Для решения этой проблемы в ash существует синтаксис here-document, который в общем виде выглядит так</p>\n<pre><code>[n]&lt;&lt; delimiter\n    here-doc-text ...\ndelimiter\n</code></pre>\n<p>delimiter может быть любой последовательностью символов, первый раз после указания delimiter на следующей строке должны начаться данные, после второго указания delimiter с начала строки данные завершились. Обычно delimiter указывают EOL - как аббревиатура End Of Line, но он может быть и другой последовательностью символов.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span><span class=\"token operator\">&lt;</span> EOL\n<span class=\"token operator\">></span> very very very\n<span class=\"token operator\">></span> long long long\n<span class=\"token operator\">></span> text text text\n<span class=\"token operator\">></span> EOL\nvery very very\nlong long long\ntext text text</code></pre>\n<p>В интерактивном режиме после EOL и переноса строки shell символом <code>&gt;</code> в начале строки подсказывает что ввод команды продолжается.</p>\n<p>Для скриптов heredoc используется аналогично</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOL\n1\n2\n3\nEOL</span>\n$ ash test.sh\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Если требуется в скрипте визуально отделить содержимое heredoc, можно использовать символ табуляции и добавить оператор <code>&lt;&lt;-</code> – в этом случае shell удалит все табы с начала строк</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;-</span> <span class=\"token string\">EOL\n&lt;tab>1\n&lt;tab>2\n&lt;tab>3\nEOL</span>\n$ ash test.sh\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Кроме этого внутри heredoc можно использовать shell-переменные</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOL\npwd = <span class=\"token environment constant\">$PWD</span>\nEOL</span>\n$ ash test.sh\n<span class=\"token builtin class-name\">pwd</span> <span class=\"token operator\">=</span> /home/ubuntu</code></pre>\n<p>Чтобы текст внутри heredoc обрабатывался как обычные символы без подстановки переменных, нужно первый delimiter заключить в кавычки (двойные или одинарные)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'EOL'\npwd = $PWD\nEOL</span>\n$ ash test.sh\n<span class=\"token builtin class-name\">pwd</span> <span class=\"token operator\">=</span> <span class=\"token environment constant\">$PWD</span></code></pre>\n<h3 id=\"rabota-s-deskriptorami\" tabindex=\"-1\"><a id=\"descriptors\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#descriptors\"></a> Работа с дескрипторами <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#rabota-s-deskriptorami\" aria-hidden=\"true\">#</a></h3>\n<p>Еще одна фича для работы с дескрипторами файлов — это возможность открыть файл в какой-то номер дескриптора, номера могут быть от 0 до 9.</p>\n<p>Для того чтобы использовать номер дескриптора в скрипте или интерактивном shell для нескольких команд нужно использовать builtin-команду exec (подробнее мы рассмотрим ее в следующих статьях).</p>\n<p>Сейчас нам нужно знать что все перенаправления выполненные в exec становятся постоянными (permanant) в рамках шелла или скрипта, то есть открытые дескрипторы можно использовать для последующих команд.</p>\n<h3 id=\"operator-n-file-4\" tabindex=\"-1\"><a id=\"operator-open-descriptor\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-open-descriptor\"></a> оператор <code>[n]&lt;&gt; file</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n-file-4\" aria-hidden=\"true\">#</a></h3>\n<p>Позволяет открыть дескриптор файла на чтение и запись</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># открываем поток (дескриптор файла) с номером 3 для файла tmp.txt</span>\n$ <span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;></span> ./tmp.txt\n<span class=\"token comment\"># так как команда была выполнена с помощью exec</span>\n<span class=\"token comment\"># дескриптор доступен для следующих команд</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'2'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'3'</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token function\">cat</span> ./tmp.txt\n<span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\n<span class=\"token number\">3</span></code></pre>\n<h3 id=\"operator-n\" tabindex=\"-1\"><a id=\"operator-close-descriptor\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-close-descriptor\"></a> оператор <code>[n]&gt;-</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#operator-n\" aria-hidden=\"true\">#</a></h3>\n<p>Закрыть дескриптор файла</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># продолжая предыдущий пример</span>\n$ <span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span>-\n<span class=\"token comment\"># дескриптор файла tmp.txt закрыт</span>\n<span class=\"token comment\"># если снова открыть дескриптор,</span>\n<span class=\"token comment\"># то запись или чтение из файла начнется с начала</span>\n$ <span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;></span> ./tmp.txt\n<span class=\"token comment\"># читаем из дескриптора 2 байта (1\\n) - единицу и перенос строки</span>\n$ <span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;</span><span class=\"token file-descriptor important\">&amp;3</span>\n<span class=\"token comment\"># сейчас указатель дексриптора указывает на вторую строку (2\\n)</span>\n<span class=\"token comment\"># запишем 9</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">9</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n$ <span class=\"token function\">cat</span> ./tmp.txt\n<span class=\"token number\">1</span>\n<span class=\"token number\">9</span>\n<span class=\"token number\">3</span></code></pre>\n<p>Аналогично можно работать с input с помощью операторов <code>[n1]&lt;&amp;n2</code>, <code>[n]&lt;-</code></p>\n<p> </p>\n<h1 id=\"\" tabindex=\"-1\">= <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#\" aria-hidden=\"true\">#</a></h1>\n<p>Сегодня мы разобрались с перенаправлением потоков stdin, stdout, stderr и возможностями использовать дескрипторы файлов в скриптах. В следующих статьях поговорим про сложные команды, пайпы, условия выполнения и циклы.</p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-5-ash-complex-commands/\">shells, ash #4 - ash syntax, complex commands, pipelines, conditions and loops</a></p>\n<p> </p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/2021-01-linux-tools-shells-part-4-ash-redirections/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li><a href=\"https://www.gnu.org/software/bash/manual/html_node/Redirections.html\" target=\"_blank\" rel=\"noopener\">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a></li>\n<li><a href=\"https://tldp.org/LDP/abs/html/io-redirection.html\" target=\"_blank\" rel=\"noopener\">https://tldp.org/LDP/abs/html/io-redirection.html</a></li>\n<li><a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/dash.1.html</a></li>\n</ul>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-tools\">Все статьи серии “Linux Tools”</a></p>\n",
      "date_published": "2021-01-02T20:22:00Z"
    },{
      "id": "https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/",
      "url": "https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/",
      "title": "Linux Tools: shells, ash #2 - ash syntax, simple commands",
      "content_html": "<p>В прошлой статье поговорили про запуск ash, в этой начнем разбираться с самым интересным - синтаксис и написание shell-скриптов. Для изучения продолжаем использовать ash из busybox.</p>\n<!--more -->\n<p>Предыдущая статья: <a href=\"https://rootaround.github.io/posts/blog/2020-12-linux-tools-shells-part-2-ash-startup/\">shells, ash #1 - ash startup and arguments</a></p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-4-ash-redirections/\">shells, ash #3 - ash syntax, redirections</a></p>\n<p>Тут нужно сделать небольшое отступление про стандарты. Существует стандарт POSIX 1003.2, который определяет много чего, но сейчас нам важно что он определяет как должна работать командная оболочка, какие команды должны существовать, как работать.</p>\n<p>Так вот ash практически ее поддерживает судя по документации:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">..</span>. is <span class=\"token keyword\">in</span> the process of being changed to conform\nwith the POSIX <span class=\"token number\">1003.2</span> and <span class=\"token number\">1003</span>.2a specifications <span class=\"token keyword\">for</span> the shell.\n\n<span class=\"token punctuation\">..</span>.\n\nOnly features designated by POSIX, plus a few Berkeley extensions,\nare being incorporated into this shell.\n\n<span class=\"token punctuation\">..</span>.</code></pre>\n<p>Видимо полная реализация стандарта довольно трудоемкое (и противоречивое) занятие, поэтому даже этот шелл имеет какие-то свои нестандартные фичи. К слову у bash их еще больше и называют их bashisms, но в нем есть режим совместимости с POSIX.</p>\n<p>Возвращаемся к ash и сегодня поговорим про то как можно писать команды и какой синтаксис и удобства предоставляет нам шелл.</p>\n<p>ash читает скрипт построчно, разбивает его на слова по пробелам и табам. Дальше некоторые последовательности символов определяются как операторы. Операторы бывают двух видов:</p>\n<ol>\n<li>Control operators — для объединения команд в группы, цепочки-пайпланы и условия</li>\n</ol>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">&amp;</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">|</span> <span class=\"token operator\">||</span> <span class=\"token operator\">&lt;</span>newline<span class=\"token operator\">></span></code></pre>\n<ol start=\"2\">\n<li>Redirection operators — для перенаправления потоков между командами и не только</li>\n</ol>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">&lt;</span> <span class=\"token operator\">></span> <span class=\"token operator\">>|</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">>></span> <span class=\"token operator\">&lt;&amp;</span> <span class=\"token operator\">>&amp;</span> <span class=\"token operator\">&lt;&lt;-</span> <span class=\"token operator\">&lt;></span></code></pre>\n<p>Стандартной проблемой в шеллах и в языках программирования является использование специальных символов (и последовательностей) как обычных символов – это называют экранированием (escape special chars). В ash экранирование спец символов можно сделать 3 способами:</p>\n<ul>\n<li>обратный слэш — backslash</li>\n<li>парные одинарные кавычки — matched single quotes</li>\n<li>парные двойные кавычки — matched double qoutes</li>\n</ul>\n<h3 id=\"obratnyj-slesh-backslash\" tabindex=\"-1\"><a id=\"backslash\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#backslash\"></a> обратный слэш — backslash <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#obratnyj-slesh-backslash\" aria-hidden=\"true\">#</a></h3>\n<p>Backslash перед спец символом делает его обычным символом</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># команда ничего не выведет,</span>\n<span class=\"token comment\"># потому что точка с запятой интеретируется как разделитель команд</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># выведется точка с запятой, как обычный символ</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">;</span></code></pre>\n<p>Кроме этого backslash перед символом конца строки (переводом строки) интерпретируется как продолжение строки</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">\\</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">\\</span>\n<span class=\"token number\">3</span>\n<span class=\"token number\">123</span></code></pre>\n<h3 id=\"parnye-odinarnye-kavychki-matched-single-quotes\" tabindex=\"-1\"><a id=\"single-quotes\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#single-quotes\"></a> парные одинарные кавычки — matched single quotes <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#parnye-odinarnye-kavychki-matched-single-quotes\" aria-hidden=\"true\">#</a></h3>\n<p>Все что внутри одинарных кавычек, кроме одинарных кавычек, считается обычным символом</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'&amp;;|>>'</span>\n<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">;</span><span class=\"token operator\">|</span><span class=\"token operator\">>></span></code></pre>\n<p>Одинарные кавычки при необходимости можно вывести отдельно с помощью <a href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#backslash\">backslash</a></p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># последняя кавычка экранирована с помощью backslash</span>\n<span class=\"token comment\"># и считается обычным символом</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'&amp;|$'</span><span class=\"token punctuation\">\\</span>'\n<span class=\"token operator\">&amp;</span><span class=\"token operator\">|</span><span class=\"token string\">$'\n\n$ echo '</span><span class=\"token environment constant\">$PATH</span>'\n<span class=\"token environment constant\">$PATH</span></code></pre>\n<h3 id=\"parnye-dvojnye-kavychki-matched-double-qoutes\" tabindex=\"-1\"><a id=\"double-quotes\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#double-quotes\"></a> парные двойные кавычки — matched double qoutes <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#parnye-dvojnye-kavychki-matched-double-qoutes\" aria-hidden=\"true\">#</a></h3>\n<p>С двойными кавычками все немного сложнеe. Все символы внутри двойных кавычек считаются обычными, за исключением символов знака доллара (dollarsign) - <code>$</code>, обратной кавычки (backquote) - <code>`</code> и обратного слэша (backslash) - <code>\\</code></p>\n<p>backslash внутри двойных кавычек позволяет экранировать только символы: <code>$ ` &quot; \\ &lt;newline&gt;</code></p>\n<p>Кратко рассмотрим зачем вообще нужны эти символы – дальше они будут разобраны подробнее.</p>\n<p><code>$</code> - dollarsign</p>\n<p>с помощью <code>$</code> можно использовать shell-переменные вообще без кавычек</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/sbin:/usr/sbin:/bin:/usr/bin\n\n<span class=\"token comment\"># аналогично $ работает в двойных кавычках</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token environment constant\">$PATH</span>\"</span>\n/sbin:/usr/sbin:/bin:/usr/bin</code></pre>\n<p><code>`</code> - backquote</p>\n<p>команда, заключенная в обратные кавычки, выполняется и output команды подставляется вместо обратных кавычек. Работает и без двойных кавычек.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">`</span></span>\n/home/ubuntu\n\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"current directory is <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">`</span></span>\"</span>\ncurrent directory is /home/ubuntu</code></pre>\n<p><code>\\</code> - backslash</p>\n<p>работает как и раньше, экранирует символы: <code>$ ` &quot; \\ </code> и backslash перед переводом строки считается продолжением строки без переноса</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token environment constant\">$PWD</span> = \\\n<span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token environment constant\">$PWD</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>\"</span>\n<span class=\"token environment constant\">$PWD</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"/home/ubuntu\"</span></code></pre>\n<h3 id=\"kombinirovanie-raznyh-kavychek-dlya-komand-i-argumentov\" tabindex=\"-1\"><a id=\"combine-quotes\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#combine-quotes\"></a> Комбинирование разных кавычек для команд и аргументов <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#kombinirovanie-raznyh-kavychek-dlya-komand-i-argumentov\" aria-hidden=\"true\">#</a></h3>\n<p>Все способы формирования можно комбинировать: использовать поочерердно разные кавычки, переменные:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> my<span class=\"token string\">' path is '</span><span class=\"token string\">\" = \"</span><span class=\"token environment constant\">$PWD</span><span class=\"token string\">\"\"</span>\nmy path is  <span class=\"token operator\">=</span> /home/ubuntu</code></pre>\n<p>Главное чтобы в рамках одного аргумента строки соединялись без пробелов, иначе после пробела shell будет считать строку уже другим аргументом.</p>\n<h2 id=\"komandy\" tabindex=\"-1\"><a id=\"commands\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#commands\"></a> Команды <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#komandy\" aria-hidden=\"true\">#</a></h2>\n<p>Вот мы и подобрались к сути, ведь shell нужен как раз для выполнения команд.</p>\n<p>Если при обработке строки скрипта первое слово не является зарезервирванным, то ash начинает обработку этой строки как команды.</p>\n<p>Команды могут быть простыми — вызов одной команды, или сложными конструкциями из нескольких связанных команд с условиями или без. Начнем по порядку с простых команд.</p>\n<p>Для примера рассмотрим команду <code>env</code>, которая выводит текущие переменные окружения (environment variables).</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu</code></pre>\n<p>Команда вывела несколько переменных окружнения:</p>\n<ul>\n<li><code>SHLVL</code> - текущий уровень “вложенности” шеллов, если в этом шелл запустить еще раз команду ash - SHLVL будет равен 2, а внутри этого шелла запустить еще один, то в нем будет SHLVL=3 и так далее</li>\n<li><code>PATH</code> - пути разделенные двоеточиями где нужно искать команды — об этом поговорим чуть дальше</li>\n<li><code>PWD</code> - текущая директория, в которой в данный момент мы находимся, эта env-переменная менятся при переходе между директориями командой <code>cd</code></li>\n</ul>\n<h3 id=\"neskolko-slov-pro-peremennye-variables\" tabindex=\"-1\"><a id=\"variables\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#variables\"></a> Несколько слов про переменные - variables <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#neskolko-slov-pro-peremennye-variables\" aria-hidden=\"true\">#</a></h3>\n<p>Команда запускает процесс, у процесса могут быть переменные окружения (environment variables, env vars). Переменные окружения для конкретной команды можно задать непосредственно при вызове:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token function\">env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token comment\"># &lt;&lt;&lt; переменная 'a' есть в переменных окружения</span></code></pre>\n<p>Вообще и в интерактивном шелле и в скриптах все что соответствует паттертну <code>name=value</code> с начала строки (или после служебного слова) считается переменной и если после переменных следует команда, то все эти переменные попадут в переменные окружения процесса запущенного этой командой:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">b</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token function\">env</span>\n<span class=\"token comment\"># ...</span>\n<span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\">b</span><span class=\"token operator\">=</span><span class=\"token number\">2</span></code></pre>\n<p>Если переменные указаны без команды, то они определяются как переменные шелла - shell variables.</p>\n<p>Shell variables доступны для подстановки в самом шелле, но во все выполняемые команды передаются только environment variables.</p>\n<p>Shell-переменные (в том числе environment-переменные) можно посмотреть builtin-командой <code>set</code>, а env-переменные командой <code>env</code> или <code>export</code>.</p>\n<p>Несколько примеров чтобы стало понятнее</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># определяем shell-переменную my_test_var</span>\n$ <span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token comment\"># смотрим что переменная определилась</span>\n<span class=\"token comment\"># в результатах set выводятся вообще все переменные,</span>\n<span class=\"token comment\"># в том числе environment variables</span>\n$ <span class=\"token builtin class-name\">set</span>\n<span class=\"token comment\"># ...</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PS4</span></span><span class=\"token operator\">=</span><span class=\"token string\">'+ '</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span><span class=\"token string\">'/home/ubuntu'</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token string\">'1'</span>\n<span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token string\">'1'</span> <span class=\"token comment\"># &lt;&lt;&lt; тут есть переменная 'my_test_var'</span>\n\n<span class=\"token comment\"># так как my_test_var еще не environment variable,</span>\n<span class=\"token comment\"># ее нет в выводе команды env</span>\n$ <span class=\"token function\">env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n\n<span class=\"token comment\"># но ее можно использовать в самом шелле</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'my_test_var = '</span><span class=\"token variable\">$my_test_var</span>\nmy_test_var <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\"># для того чтобы переменная стала environment-переменной</span>\n<span class=\"token comment\"># ее нужно экспортировать</span>\n$ <span class=\"token builtin class-name\">export</span> my_test_var\n\n<span class=\"token comment\"># теперь переменная my_test_var является environment-переменной</span>\n<span class=\"token comment\"># и передаётся в environment всех команд запущенных в шелле</span>\n$ <span class=\"token function\">env</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/sbin:/usr/sbin:/bin:/usr/bin\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/home/ubuntu\n<span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token comment\"># &lt;&lt;&lt;</span>\n\n<span class=\"token comment\"># для конкретного вызова команды</span>\n<span class=\"token comment\"># environment-переменную всегда можно переопределить</span>\n$ <span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span> <span class=\"token function\">env</span>\n<span class=\"token comment\"># ...</span>\n<span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">100500</span></code></pre>\n<p>Пример показывает что все переменные доступны для подстановки внутри shell, но только environment-переменные передаются в окружение всем командам, выполняемым в shell.</p>\n<p>В названии переменных могут использоваться символы латинского алфавита, числа и символ подчеркивания, название переменной не может начинаться с числа.</p>\n<p>Для более явного разделения переменных существует негласное правило:</p>\n<blockquote>\n<p>environment-переменные пишутся заглавными буквами, а обычные shell-переменные строчными</p>\n</blockquote>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># PATH - environment-переменная</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n\n<span class=\"token comment\"># my_test_var - обычная shell-переменная</span>\n$ <span class=\"token assign-left variable\">my_test_var</span><span class=\"token operator\">=</span><span class=\"token number\">1</span></code></pre>\n<p> </p>\n<h1 id=\"itogo\" tabindex=\"-1\">Итого <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#itogo\" aria-hidden=\"true\">#</a></h1>\n<p>Сегодня начали разбирать синтаксис и посмотрели как можно писать команды и аргументы с помощью кавычек, как формируется команда, как работать с переменными в общем и с переменными окружения в частности. В следующей статье разберемся как управлять перенаправлением потоков stdin, stdout и stderr с помощью redirection operators.</p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2021-01-linux-tools-shells-part-4-ash-redirections/\">shells, ash #3 - ash syntax, redirections</a></p>\n<p> </p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-3-ash-commands/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li><a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/dash.1.html</a></li>\n</ul>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-tools\">Все статьи серии “Linux Tools”</a></p>\n",
      "date_published": "2020-12-29T20:12:00Z"
    },{
      "id": "https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/",
      "url": "https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/",
      "title": "Linux Tools: shells, ash #1 - ash startup and arguments",
      "content_html": "<p>ash - это минималистичный shell, который предоставляет меньше удобств по сравнению с bash, но по функционалу для скриптинга совместим с bash.</p>\n<!-- more -->\n<p>Первая статья: <a href=\"https://rootaround.github.io/posts/blog/2020-12-linux-tools-shells-part-1-historical/\">Linux Tools: shells - историческая часть</a></p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2020-12-linux-tools-shells-part-3-ash-commands/\">Linux Tools: shells, , ash #2 - ash syntax, simple commands</a></p>\n<p>В первой статье серии немного рассмотрели историю развития шеллов, на практике в статье <a href=\"https://rootaround.github.io/posts/blog/linux-first-boot-mbr\">“Linux First: Загрузка ядра”</a> мы уже использовали ash в качестве login shell и пришло время разобраться подробнее с режимами запуска и аргументами.</p>\n<p>Документации на ash в busybox нет, поэтому смотреть можно доку на dash — <a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/dash.1.html</a>, тем более что сейчас в busybox за основу взята именно <a href=\"https://git.busybox.net/busybox/tree/shell/ash.c#n28\" target=\"_blank\" rel=\"noopener\">эта версия</a>.</p>\n<h1 id=\"interactive-shell\" tabindex=\"-1\"><a id=\"interactive-shell\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#interactive-shell\"></a> Interactive shell <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#interactive-shell\" aria-hidden=\"true\">#</a></h1>\n<p>Шелл может быть запущен в интерактивным и неинтерактивном режимах. По умолчанию ash запускается в интерактивном режиме, принудительно можно включить режим опцией <code>-i</code>. В этом режиме команды ожидаются из stdin - стандартного input потока.</p>\n<p>Пара слов про потоки (streams), каждый linux-процесс имеет три потока: stdin, stdout, stderr.</p>\n<ul>\n<li>из <strong>stdin</strong> можно читать входные данные, например, другой команды. Упрощенно - через stdin передается ввод команд с клавиатуры в интерактивном режиме;</li>\n<li>в <strong>stdout</strong> процесс пишет свой вывод, результаты;</li>\n<li>в <strong>stderr</strong> должны записываться сообщения об ошибках и отладке.</li>\n</ul>\n<p>Подробнее с потоками и дескрипторами разбираться будем в серии Linux First.</p>\n<p>Интерактивный режим позволяет вводить, редактировать и выполнять команды снова, видеть ошибки выполнения команд, в общем напрямую взаимодействовать с системой.</p>\n<h1 id=\"zapusk-shell-skriptov-non-interactive-shell\" tabindex=\"-1\"><a id=\"script-shell\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#script-shell\"></a> Запуск shell-скриптов - non-interactive shell <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#zapusk-shell-skriptov-non-interactive-shell\" aria-hidden=\"true\">#</a></h1>\n<p>Противоположность интерактивному режиму - запуск скриптов с помощью ash, это режим включается при указании пути к скрипту или аргумента <code>-c</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash ./test.sh\n\n$ ash <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo 100500'</span></code></pre>\n<p>С этим режимом связано довольно много аргументов ash, помогающих разрабатывать скрипты.</p>\n<h2 id=\"noexec-argument-n\" tabindex=\"-1\"><a id=\"noexec-arg-adv\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noexec-arg-adv\"></a> noexec - аргумент <code>-n</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noexec-argument-n\" aria-hidden=\"true\">#</a></h2>\n<p>Проверка скрипта без выполнения команд. Работает только при выполнении файла-скрипта, но <strong>не</strong> работает при указании команд через <code>-c</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n\n$ ash test.sh\n<span class=\"token number\">123</span>\n\n$ ash <span class=\"token parameter variable\">-n</span> test.sh</code></pre>\n<p>У последней команды не будет никакого вывода, потому что указан аргумент <code>-n</code> и команды echo и exit не будет выполнены, но в случае именно ошибки синтаксиса выведется текст ошибки и ненулевой exit code.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token operator\">&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\"># '&amp;' в начале это ошибка в shell-скрипте</span>\n\n$ ash <span class=\"token parameter variable\">-n</span> test.sh\n./test.sh: line <span class=\"token number\">1</span>: syntax error: unexpected <span class=\"token string\">\"&amp;\"</span></code></pre>\n<p>Конечно этот режим не проверяет наличие самих команд, но для проверки синтаксиса удобно.</p>\n<h2 id=\"verbose-argument-v\" tabindex=\"-1\"><a id=\"verbose-arg-adv\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#verbose-arg-adv\"></a> verbose - аргумент <code>-v</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#verbose-argument-v\" aria-hidden=\"true\">#</a></h2>\n<p>В stderr будет записано все что ash читает в процессе работы.</p>\n<p>Например, в login-режиме (про него далее) читается файл <code>$HOME/.profile</code> и выполняются команды из него – с опцией <code>-v</code> все содержимое <code>.profile</code> будет записано в stderr для отладки.</p>\n<h2 id=\"xtrace-argument-x\" tabindex=\"-1\"><a id=\"xtrace-arg-adv\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#xtrace-arg-adv\"></a> xtrace - аргумент <code>-x</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#xtrace-argument-x\" aria-hidden=\"true\">#</a></h2>\n<p>С этим аргументом каждая выполняемая команда будет записано в stderr</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n\n$ ash <span class=\"token parameter variable\">-x</span> test.sh\n+ <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">123</span>\n<span class=\"token number\">123</span>\n+ <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span></code></pre>\n<p>Вообще все опции включатся через <code>-</code> , а выключаются через <code>+</code> <em>// кажется что нелогично и должно быть наоборот</em></p>\n<p>В интерактивном режиме тоже можно включать опции с помощью builtin-команды set</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">set</span> <span class=\"token parameter variable\">-x</span>\n\n<span class=\"token comment\"># xtrace ВКЛючен</span>\n\n$ <span class=\"token builtin class-name\">set</span> +x\n\n<span class=\"token comment\"># xtrace ВЫКЛючен</span></code></pre>\n<h2 id=\"errexit-argument-e\" tabindex=\"-1\"><a id=\"errexit-arg-adv\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#errexit-arg-adv\"></a> errexit - аргумент <code>-e</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#errexit-argument-e\" aria-hidden=\"true\">#</a></h2>\n<p>С <code>-e</code> все непротестированные команды (без проверки exit-кода через <code>if</code>, <code>elif</code>) будут приводить к завершению скрипта.</p>\n<p>Для примера рассмотрим скрипт с листингом несуществующей директории.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token function\">ls</span> /none<span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'good'</span>\n\n$ ash test.sh\nls: /none: No such <span class=\"token function\">file</span> or directory\ngood\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">0</span></code></pre>\n<p>При обычном запуске команды <code>ls</code> и <code>echo</code> выполняются независимо друг от друга и <code>echo</code> будет выполнено после <code>ls</code> <em>// конечно в данном случае нужно использовать <code>&amp;&amp;</code>, но об этом в следующих статьях</em></p>\n<p>С аргументом <code>-e</code> выход из скрипта произойдет после <code>ls</code> и скрипт завершится с ненулевым exit-кодом.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash <span class=\"token parameter variable\">-e</span> test.sh\nls: /none: No such <span class=\"token function\">file</span> or directory\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$?</span>\n<span class=\"token number\">1</span></code></pre>\n<p>Еще один полезный момент — передача параметров при запуске скрипта. Все аргументы после указания пути к скрипту считаются позиционными аргументами и могут быть почитаны в скрипте из переменных $1, $2</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$11</span>\n\n$ ash test.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">6</span> <span class=\"token number\">7</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">10</span> <span class=\"token number\">11</span>\n<span class=\"token number\">1</span>\n<span class=\"token number\">11</span></code></pre>\n<p>Отдельно стоит отметить $0 - это переменная содержит путь к скрипту</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$0</span>\n\n$ ash ./test.sh\n./test.sh</code></pre>\n<h2 id=\"login-shell\" tabindex=\"-1\"><a id=\"login-shell\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#login-shell\"></a> login shell <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#login-shell\" aria-hidden=\"true\">#</a></h2>\n<p>Еще одним режимом запуска является login, включается опцией <code>-l</code> или передачей первым аргументом символа <code>-</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash <span class=\"token parameter variable\">-l</span>\n\n$ ash -</code></pre>\n<p>Работает в interactive и non-interactive режимах.</p>\n<p>Смысл режима инициализировать окружение для пользователя. В login-режиме ash ищет и выполняет shell-скрипты <code>/etc/profile</code> и <code>$HOME/.profile</code>. Если в этих файлах указать и экспортировать переменную ENV, в которой указать путь к файлу, его содержимое также будет обработано и выполнено как shell-скрипт на этапе запуска.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">ENV</span><span class=\"token operator\">=</span><span class=\"token environment constant\">$HOME</span>/.shinit<span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">export</span> ENV</code></pre>\n<p> </p>\n<h1 id=\"arguments\" tabindex=\"-1\"><a id=\"args\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#args\"></a> Arguments <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#arguments\" aria-hidden=\"true\">#</a></h1>\n<p>Для полноты картины пройдемся по всем аргументам команды bash</p>\n<p> </p>\n<h2 id=\"a\" tabindex=\"-1\"><a id=\"allexport-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#allexport-arg\"></a> <code>-a</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#a\" aria-hidden=\"true\">#</a></h2>\n<p>allexport</p>\n<p>Экспорт env-переменных <em>// не увидел разницы с обычным режимом, все назначенные переменные окружения и так видны внутри shell при запуске</em></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">env</span> <span class=\"token parameter variable\">-i</span> <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span> ash <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo $TEST'</span>\n<span class=\"token number\">100</span>\n\n$ <span class=\"token function\">env</span> <span class=\"token parameter variable\">-i</span> <span class=\"token assign-left variable\">TEST</span><span class=\"token operator\">=</span><span class=\"token number\">100</span> ash <span class=\"token parameter variable\">-a</span> <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo $TEST'</span>\n<span class=\"token number\">100</span></code></pre>\n<h2 id=\"c\" tabindex=\"-1\"><a id=\"command-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#command-arg\"></a> <code>-c</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#c\" aria-hidden=\"true\">#</a></h2>\n<p>Режим выполнения команд, выполняет команды указанные после аргумента</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ ash <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'echo 100500'</span>\n<span class=\"token number\">100500</span></code></pre>\n<h2 id=\"c-1\" tabindex=\"-1\"><a id=\"noclobber-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noclobber-arg\"></a> <code>-C</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#c-1\" aria-hidden=\"true\">#</a></h2>\n<p>noclobber <em>// не колошматить 😃</em></p>\n<p>тут речь про оператор <code>&gt;</code> при перенаправление потока в файл, по умолчанию этот оператор создает или перезаписывает содержимое файла, аргумент <code>-C</code> меняет это поведение — если файл уже существует, произойдет ошибка.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># скрипт записывает значение первого аргумента в файл tmp.txt</span>\n$ <span class=\"token function\">cat</span> ./test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$1</span> <span class=\"token operator\">></span> tmp.txt\n\n<span class=\"token comment\"># выполняем</span>\n$ ash ./test.sh <span class=\"token number\">100</span>\n\n<span class=\"token comment\"># в файл записано 100</span>\n$ <span class=\"token function\">cat</span> tmp.txt\n<span class=\"token number\">100</span>\n\n<span class=\"token comment\"># выполняем еще раз</span>\n$ ash ./test.txt <span class=\"token number\">101</span>\n\n<span class=\"token comment\"># файл перезаписан со значением 101</span>\n$ <span class=\"token function\">cat</span> tmp.txt\n<span class=\"token number\">101</span>\n\n<span class=\"token comment\"># выполняем c аргументом -C - получаем ошибку</span>\n$ ash <span class=\"token parameter variable\">-C</span> ./test.txt <span class=\"token number\">102</span>\ntest.sh: line <span class=\"token number\">1</span>: can't create test.txt: File exists</code></pre>\n<h2 id=\"e\" tabindex=\"-1\"><a id=\"errexit-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#errexit-arg\"></a> <code>-e</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#e\" aria-hidden=\"true\">#</a></h2>\n<p>errexit</p>\n<p>Этот аргумент <a href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#errexit-arg-adv\">рассмотрели выше</a> — выход из скрипта, если команда завершается с ненулевым exit-кодом и не обработана условиями типа <code>if</code></p>\n<h2 id=\"f\" tabindex=\"-1\"><a id=\"noglob-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noglob-arg\"></a> <code>-f</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#f\" aria-hidden=\"true\">#</a></h2>\n<p>noglob</p>\n<p>В шеллах существует прекрасная штука - file globbing - это возможность указывать путь к файлам не полностью, а, например, через wildcard — <code>cat *.txt</code> — вывести на экран все файлы с расширением txt.</p>\n<p>Так вот опция <code>-f</code> отключает file globbing для выполняемого скрипта.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token comment\"># this is script</span>\n<span class=\"token function\">cat</span> *.sh\n\n<span class=\"token comment\"># выводит все файлы с расширением sh</span>\n$ ash test.sh\n<span class=\"token comment\"># this is script</span>\n<span class=\"token function\">cat</span> *.sh\n\n<span class=\"token function\">file</span> globbing отключен - *.sh интерпретируется как имя файла\n$ ash <span class=\"token parameter variable\">-f</span> test.sh\ncat: can<span class=\"token string\">'t open '</span>*.sh': No such <span class=\"token function\">file</span> or directory</code></pre>\n<h2 id=\"n\" tabindex=\"-1\"><a id=\"noexec-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noexec-arg\"></a> <code>-n</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#n\" aria-hidden=\"true\">#</a></h2>\n<p>noexec</p>\n<p>Не выполняет команды, удобно для проверки синтаксиса, подробнее <a href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#noexec-arg-adv\">рассмотрели выше</a></p>\n<h2 id=\"u\" tabindex=\"-1\"><a id=\"nounset-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#nounset-arg\"></a> <code>-u</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#u\" aria-hidden=\"true\">#</a></h2>\n<p>nounset</p>\n<p>Завершать скрипт с ошибкой если происходит обращение к переменной, которая не определена.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$SOME</span>\n\n<span class=\"token comment\"># скрипт успешно выполнен, хотя переменная SOME не определена</span>\n$ ash test.sh\n\n<span class=\"token comment\"># с аргументом -u присходит ошибка</span>\n$ ash <span class=\"token parameter variable\">-u</span> test.sh\ntest.sh: line <span class=\"token number\">1</span>: SOME: parameter not <span class=\"token builtin class-name\">set</span></code></pre>\n<h2 id=\"v\" tabindex=\"-1\"><a id=\"verbose-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#verbose-arg\"></a> <code>-v</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#v\" aria-hidden=\"true\">#</a></h2>\n<p>verbose</p>\n<p>Выводит в stderr все shell-файлы, которые ash читает и выполняет</p>\n<h2 id=\"x\" tabindex=\"-1\"><a id=\"xtrace-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#xtrace-arg\"></a> <code>-x</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#x\" aria-hidden=\"true\">#</a></h2>\n<p>xtrace</p>\n<p>Выводит в stderr все команды, которые ash выполняет</p>\n<h2 id=\"i\" tabindex=\"-1\"><a id=\"ignoreeof-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#ignoreeof-arg\"></a> <code>-I</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#i\" aria-hidden=\"true\">#</a></h2>\n<p>ignoreeof</p>\n<p>Игнорирует EOF (символы конца строки) из stdin</p>\n<p><em>// Пока не очень понятно зачем это нужно, но работает так</em></p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># echo передает EOF (/n) после строки и скрипт выводит содержимое файла скриптов</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'cat *.sh'</span> <span class=\"token operator\">|</span> ash\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$SOME</span>\n\n<span class=\"token comment\"># с -I конец строки игнорируется и будет ошибка</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'cat *.sh'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-I</span>\nUse <span class=\"token string\">\"exit\"</span> to leave shell.\n\nUse <span class=\"token string\">\"exit\"</span> to leave shell.\n\n<span class=\"token punctuation\">..</span>.</code></pre>\n<h2 id=\"i-1\" tabindex=\"-1\"><a id=\"interactive-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#interactive-arg\"></a> <code>-i</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#i-1\" aria-hidden=\"true\">#</a></h2>\n<p>interactive</p>\n<p>принудительно включается интерактивный режим</p>\n<h2 id=\"l\" tabindex=\"-1\"><a id=\"login-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#login-arg\"></a> <code>-l</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#l\" aria-hidden=\"true\">#</a></h2>\n<p>login</p>\n<p>Включает login-режим</p>\n<h2 id=\"m\" tabindex=\"-1\"><a id=\"monitor-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#monitor-arg\"></a> <code>-m</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#m\" aria-hidden=\"true\">#</a></h2>\n<p>monitor</p>\n<p>включает job control, автоматически включается в интерактивном режиме, видимо позволяет включать работу с jobs в скриптах <em>// рассмотрим позже, но уже интересно — можно запустить задачу фоном в скрипте, а потом проконтролировать ее и завершить скрипт</em></p>\n<h2 id=\"s\" tabindex=\"-1\"><a id=\"stdin-arg\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#stdin-arg\"></a><code>-s</code> <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#s\" aria-hidden=\"true\">#</a></h2>\n<p>stdin</p>\n<p>читать скрипт из stdin. Если не указан путь к скрипту, то включено.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span>\n\n<span class=\"token comment\"># идентично c -s</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-s</span>\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span>\n\n<span class=\"token comment\"># но не работает если указан скрипт</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-s</span> test.sh\n<span class=\"token comment\"># test script commands</span>\n\n<span class=\"token comment\"># при этом выполняются обе команды с -c и -s</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'date'</span> <span class=\"token operator\">|</span> ash <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-c</span> <span class=\"token string\">'date'</span>\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span>\nFri Dec <span class=\"token number\">24</span> 00:38:31 UTC <span class=\"token number\">2020</span></code></pre>\n<p> </p>\n<h1 id=\"itogo\" tabindex=\"-1\">Итого <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#itogo\" aria-hidden=\"true\">#</a></h1>\n<p>Сегодня разобрали запуск ash, режимы и аргументы, в следующих статьях начнем разбирать возможности скриптов, синтаксис и команды.</p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2020-12-linux-tools-shells-part-3-ash-commands/\">Linux Tools: shells, ash #2 - ash syntax, simple commands</a></p>\n<p> </p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-2-ash-startup/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li><a href=\"https://man7.org/linux/man-pages/man1/dash.1.html\" target=\"_blank\" rel=\"noopener\">https://man7.org/linux/man-pages/man1/dash.1.html</a></li>\n</ul>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-tools\">Все статьи серии “Linux Tools”</a></p>\n",
      "date_published": "2020-12-24T19:21:00Z"
    },{
      "id": "https://rootaround.github.io/2020-12-linux-tools-shells-part-1-historical/",
      "url": "https://rootaround.github.io/2020-12-linux-tools-shells-part-1-historical/",
      "title": "Linux Tools: shells - историческая часть",
      "content_html": "<p><em>Shell, шелл, терминал, консоль, Command Line Interface, cli</em> – по сути все это название командного интерпретатора, которые существует во всех операционных системах и позволяет посылать системе команды для выполнения, собирать эти команды в скрипты и выполнять уже наборы команд.</p>\n<!--more-->\n<p>Звучит все очень просто, но так было не всегда и все удобства современных командных интерпретаторов появились не сразу. Сегодня кратко рассмотрим историю развития шеллов.</p>\n<p><strong>1971, Thompson shell</strong> - написан Кеном (внезапно) Томпсоном в Bell Labs и использовался в первой версии Unix. Кен Томпсон совместно с Денисом Ритчи являются ни много ни мало создателями операционной система Unix и языка программирования C.</p>\n<p><strong>1975, PWB (Mashey) shell</strong> - разработан Джоном Маши (John Mashey) в Bell Labs для PWB (Programmer’s Workbench) Unix - дистрибутив для разработчиков (но не взлетел). Основан на Thompson Shell c фичами для упрощения разработки.</p>\n<p>Тут следует сделать небольшое отступление – все шеллы до Borne Shell были больше нацелены на выполнения команд (интерактивный режим), а не для скриптов.</p>\n<p>Thompson Shell создавался очень минималистичным, в одной из последних был реализован концепт пайпов (<code>command1 &gt; command2</code>), но в остальном даже такие простые вещи как <code>if</code> были сделаны отдельными командами — основной функционал был направлен именно на выполнение команд.</p>\n<p>В Mashey shell <code>if</code>, <code>elseif</code>, <code>goto</code> (и другие) были добавлены как часть самого шелла, появились аналоги $HOME, $PATH.</p>\n<p>Bourne Shell был написан с нуля, фичи обсуждались с участниками сообщества, плюс популярность после публикации книги The Unix Programming Environment Брайна Кернигана и Роба Пайка — все это сыграло в пользу Borne Shell и разработка Mashey Shell была прекращена, хотя достаточно много фич из Mashey были реализованы в Borne.</p>\n<p><strong>1976, 1979, Bourne Shell (sh)</strong> - в 1976 Стивен Борн начал разработку, а в 1979 Bourne Shell был включен в Unix версии 7 как шелл по умолчанию. Это первый распространенный шелл со скриптовым языком.</p>\n<p><strong>1978, C shell (csh)</strong> – разработан Биллом Джоем, шелл с собственным синтаксисом несовместимым с sh, был широко распространен в BSD-дистрибутивах. Если <strong>sh</strong> привносил удобства написания скриптов, то <strong>сsh</strong> добавлял множество фич именно для пользователя: перенаправление потоков, пайпы, история, навигация внутри командной строки, автодополнение и еще много удобств интерактивного режима.</p>\n<p><strong>1983, Korn Shell (ksh)</strong> - разработан Дэвидом Корном и первоначально основан на bash (видимо на каких-то дорелизных версиях). Позже реализованный в ksh механизм работы с задачами (jobs) был добавлен в bash.</p>\n<p><strong>1989, Born Again Shell (bash)</strong> - первый релиз того самого шелла. Разрабатывался сначала Ричардом Столлманом, потом Брайном Фоксом. bash совместил лучшее из sh и csh, привнес свое и стал популярен в том числе благодаря Линусу Торвальдсу, который запустил bash одной из первых программ на своем новом ядре.</p>\n<p><strong>1989, Almquist shell (ash)</strong> - Kenneth Almquist выпустил первую версию легковесного шелла совместимого с Bourne Shell. ash пришел на замену sh в BSD версиях Unix. Основным плюсом была его малый размер и скорость работы и конечно совместимость с sh.</p>\n<p><strong>1990, Z Shell (zsh)</strong> - разработан Паулем Фалстадом (Paul Falstad). Кратко - это bash с кучей улучшений: история выполненных команд шарится между сессиями, программируемое автодополнение команд, коррекция опечаток (это все конечно уже в настоящее время).</p>\n<p><strong>1997, 2002, Debian Almquist shell (dash)</strong> - в 1997 Herbert Xu портирует код из NetBSD в Debian Linux, а в 2002 происходит переимнование в dash.</p>\n<p><strong>2001</strong> - код ash <a href=\"https://git.busybox.net/busybox/commit/shell/ash.c?id=cb57d551a207198fabdb8c46f96e6a0932143923\" target=\"_blank\" rel=\"noopener\">добавлен</a> в Busybox (это минимальный набор unix-утилит в одном бинарнике).</p>\n<p><strong>2005, Friendly interactive shell (fish)</strong> - начал разрабатываться Акселем Лильенкранцем. Расширенное автодополнение, подсветка синтаксиса и другие улучшения нацеленные именно на удобство пользователя.</p>\n<p><strong>2006</strong> - dash становится дефолтным шелом /bin/sh в дистрибутивах Ubuntu и Debian — вот так из 1980’ых в 2000’ые ash попал как базовый скриптовый шелл в одни из самых популярных дистрибутивов Linux.</p>\n<p>Многие шеллы завершили разработку, но в них были разработаны фичи, которые перенесли в более популярных реализации. С этой стороны, глобально, разработка каждого шелла в чем-то способствовала общему развитию.</p>\n<p> </p>\n<h1 id=\"itogo\" tabindex=\"-1\">Итого <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-1-historical/#itogo\" aria-hidden=\"true\">#</a></h1>\n<p>Дальше более подробно рассмотрим современную реализацию ash. По скриптовым возможностям ash совместим с bash, но по функционалу (особенно интерактивному) гораздо меньше — поэтому изучив ash, изучим основу bash.</p>\n<p>Следующая статья: <a href=\"https://rootaround.github.io/posts/blog/2020-12-linux-tools-shells-part-2-ash-startup/\">Linux Tools: shells, ash #1 - ash startup, ash arguments</a></p>\n<p> </p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/2020-12-linux-tools-shells-part-1-historical/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Thompson_shell\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Thompson_shell</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/PWB_shell\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/PWB_shell</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bourne_shell\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Bourne_shell</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bash_(Unix_shell)\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Bash_(Unix_shell)</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Almquist_shell\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Almquist_shell</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Z_shell\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Z_shell</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/KornShell\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/KornShell</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Ken_Thompson\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Ken_Thompson</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/John_Mashey\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/John_Mashey</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Stephen_R._Bourne\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Stephen_R._Bourne</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/The_Unix_Programming_Environment\" target=\"_blank\" rel=\"noopener\">The Unix Programming Environment</a> by <a href=\"https://en.wikipedia.org/wiki/Brian_Kernighan\" target=\"_blank\" rel=\"noopener\">Brian Kernighan</a> and <a href=\"https://en.wikipedia.org/wiki/Rob_Pike\" target=\"_blank\" rel=\"noopener\">Rob Pike</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Version_7_Unix\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Version_7_Unix</a></li>\n<li><a href=\"http://gondor.apana.org.au/~herbert/dash/\" target=\"_blank\" rel=\"noopener\">Dash by Herbert Xu</a></li>\n<li><a href=\"https://ru.wikipedia.org/wiki/BusyBox\" target=\"_blank\" rel=\"noopener\">https://ru.wikipedia.org/wiki/BusyBox</a></li>\n<li><a href=\"https://wiki.ubuntu.com/DashAsBinSh\" target=\"_blank\" rel=\"noopener\">https://wiki.ubuntu.com/DashAsBinSh</a></li>\n</ul>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-tools\">Все статьи серии “Linux Tools”</a></p>\n",
      "date_published": "2020-12-23T18:35:00Z"
    },{
      "id": "https://rootaround.github.io/linux-first-boot-mbr/",
      "url": "https://rootaround.github.io/linux-first-boot-mbr/",
      "title": "Linux First: Загрузка ядра",
      "content_html": "<p>После предыдущего поста <a href=\"https://rootaround.github.io/posts/blog/2020-05-13-linux-first-shortly-about-kernel/\">“Кратко о linux-ядре”</a> есть общее представление как устроено ядро. Дальше поговорим про загрузку компьютера в общем и ядра в частности.</p>\n<p>Попутно создадим образ жесткого диска, на базе которого продолжим разбираться с linux в следующих статьях.</p>\n<!--more-->\n<h2 id=\"zagruzka-ot-vklyucheniya-pk-do-ustrojstva\" tabindex=\"-1\">Загрузка от включения ПК до устройства <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#zagruzka-ot-vklyucheniya-pk-do-ustrojstva\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li>После включения код BIOS загружается в оперативную память (ОЗУ) из постоянной памяти (ПЗУ)</li>\n<li>После загрузки в ОЗУ код BIOS выполняет тест оборудования Power-On Self-Test (POST-тест)</li>\n<li>Читает настройки BIOS из ПЗУ</li>\n<li>Ищет и загружает в оперативную память код загрузчика</li>\n<li>Передает управление загрузчику</li>\n</ul>\n<p>Кроме этого BIOS предоставляет API для работы с устройствами еще до загрузки Операционной Системы</p>\n<p>Подробно останавливаться на этом этапе смысла нет,\nмы будем собирать образ диска с linux и загружать его используя эмулятор QEMU</p>\n<details><summary>Подробнее про QEMU</summary>\n<p><a href=\"https://www.qemu.org/\" target=\"_blank\" rel=\"noopener\">https://www.qemu.org/</a></p>\n<p>Эмулятор аппаратных платформ, позволяет эмулировать разные процессоры.</p>\n<p>Мы будем использовать qemu для x86_64</p>\n</details>\n<h2 id=\"zagruzka-s-ustrojstva\" tabindex=\"-1\">Загрузка с устройства <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#zagruzka-s-ustrojstva\" aria-hidden=\"true\">#</a></h2>\n<div class=\"info\">\n<p>Все команды выполнялись на ubuntu 16.04</p>\n</div>\n<p>BIOS в зависимости от своих настроек выбирает устройство для загрузки или последовательно проверяет несколько устройств.</p>\n<p>в случае с QEMU это выглядит так:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ qemu-system-x86_64 <span class=\"token punctuation\">\\</span> <span class=\"token comment\"># запускаем эмулятор с архитектурой x86_64</span>\n    <span class=\"token parameter variable\">-nographic</span> <span class=\"token punctuation\">\\</span>       <span class=\"token comment\"># весь вывод будет в консоль, иначе откроется gui-окно</span>\n    <span class=\"token parameter variable\">-m</span> 128m            <span class=\"token comment\"># оперативки будет 128 Мб - нам хватит</span>\n\n<span class=\"token punctuation\">..</span>.\n\nBooting from Hard Disk<span class=\"token punctuation\">..</span>.\nBoot failed: could not <span class=\"token builtin class-name\">read</span> the boot disk\n\nBooting from Floppy<span class=\"token punctuation\">..</span>.\nBoot failed: could not <span class=\"token builtin class-name\">read</span> the boot disk\n\nBooting from DVD/CD<span class=\"token punctuation\">..</span>.\nBoot failed: Could not <span class=\"token builtin class-name\">read</span> from CDROM <span class=\"token punctuation\">(</span>code 0003<span class=\"token punctuation\">)</span>\nBooting from ROM<span class=\"token punctuation\">..</span>.\n\n<span class=\"token punctuation\">..</span>.\n</code></pre>\n<div class=\"message\">\n<p>Выход из QEMU по <code>CTRL+a x</code></p>\n</div>\n<p>Ни CDROM, ни диск не указан, поэтому и загрузки не происходит.</p>\n<p>Исправляем это и создаем маленький по современным меркам жесткий диск на 256 mb.</p>\n<p>Перед созданием образа стоит поговорить про стандарты таблиц разделов на диске. Сейчас их два:</p>\n<ul>\n<li>MBR (Main Boot Record) - старый стандарт таблицы разделов (из 1983 года)</li>\n<li>GPT (Guid Partition Table) - современный стандарт разделов, является частью стандарта EFI (Extensible Firmware Interface), разработанного Intel для замены BIOS</li>\n</ul>\n<p>Подробнее про стандарты будет ссылка в конце статьи. Сейчас сделаем образ с MBR, а как-нибудь в другой серии с GPT, потому что с ним все немного сложнее</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/zero <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>./mbr_hdd.img <span class=\"token assign-left variable\">bs</span><span class=\"token operator\">=</span>1024k <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">256</span>\n<span class=\"token number\">256</span>+0 records <span class=\"token keyword\">in</span>\n<span class=\"token number\">256</span>+0 records out\n<span class=\"token number\">268435456</span> bytes transferred <span class=\"token keyword\">in</span> <span class=\"token number\">0.362737</span> secs <span class=\"token punctuation\">(</span><span class=\"token number\">740027899</span> bytes/sec<span class=\"token punctuation\">)</span></code></pre>\n<details><summary>немного про dd</summary>\n<p><code>dd</code> позволяет копировать файлы блоками заданного размера</p>\n<p>в данном случае мы копируем нули из /dev/zero блоками по 1024 килобайт (1Mb) 256 раз</p>\n<p>про dd и устройство файловой систему будем разбираться в следующих статьях</p>\n</details>\n<p>Если сразу попытаться подсунуть образ диска в qemu, то ничего не поменятся,\nтак как на диске нет таблицы разделов, а только нули.</p>\n<p>Создаем один загрузочный linux-раздел, например, с помощью fdisk (или cfdisk или parted)</p>\n<p>Должно получиться так:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">fdisk</span> <span class=\"token parameter variable\">-l</span> ./mbr_hdd.img\nDisk ./mbr_hdd.img: <span class=\"token number\">256</span> MiB, <span class=\"token number\">268435456</span> bytes, <span class=\"token number\">524288</span> sectors\nUnits: sectors of <span class=\"token number\">1</span> * <span class=\"token number\">512</span> <span class=\"token operator\">=</span> <span class=\"token number\">512</span> bytes\nSector size <span class=\"token punctuation\">(</span>logical/physical<span class=\"token punctuation\">)</span>: <span class=\"token number\">512</span> bytes / <span class=\"token number\">512</span> bytes\nI/O size <span class=\"token punctuation\">(</span>minimum/optimal<span class=\"token punctuation\">)</span>: <span class=\"token number\">512</span> bytes / <span class=\"token number\">512</span> bytes\nDisklabel type: dos\nDisk identifier: 0x00000000\n\nDevice         Boot Start    End Sectors  Size Id Type\n./mbr_hdd.img1 *     <span class=\"token number\">2048</span> <span class=\"token number\">524287</span>  <span class=\"token number\">522240</span>  255M <span class=\"token number\">83</span> Linux</code></pre>\n<p>Теперь на диске есть таблица разделов, пробуем загружаться:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ qemu-system-x86_64 <span class=\"token parameter variable\">-nographic</span> <span class=\"token parameter variable\">-m</span> 128m <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-boot</span> c <span class=\"token punctuation\">\\</span>          <span class=\"token comment\"># загружаться с жесткого диска</span>\n  <span class=\"token parameter variable\">-hda</span> ./mbr_hdd.img <span class=\"token comment\"># указываем образ первого жесткого диска</span>\n\n<span class=\"token punctuation\">..</span>.\n\nBooting from Hard Disk<span class=\"token punctuation\">..</span>.\n</code></pre>\n<p>У нас есть жесткий диск, на нем есть таблица разделов, есть загрузочный раздел - пришло время поговорить про загрузчики.</p>\n<h3 id=\"zagruzchik-bootloader\" tabindex=\"-1\">Загрузчик (bootloader) <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#zagruzchik-bootloader\" aria-hidden=\"true\">#</a></h3>\n<p>Для linux по большому счету существует два загрузчика: LILO и GRUB.</p>\n<p>LILO считается устаревшим, он не умеет работать с файловыми системами и для его конфигурации нужно каждый раз обновлять загрузочную запись на диске. Его рассматривать не будем.</p>\n<p>GRUB умеет работать с разными файловыми системами, multiboot, grub-shell, консоль восстановления и много чего еще.</p>\n<p>Конфиги GRUB, архивы с ядрами и initrd можно смотреть и править в каталоге (разделе) <code>/boot</code>.</p>\n<p>Для начала нужно создать файловую систему в разделе нашего hdd.</p>\n<p>Для реальных hdd разделы диска будут отображатся с номерами в /dev и в выводе команды <code>lsblk</code> выглядят примерно так:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># lsblk показывает блочные устройства в системе</span>\n\n$ lsblk\n\n<span class=\"token punctuation\">..</span>.\nsda         <span class=\"token number\">8</span>:0    <span class=\"token number\">0</span>    10G  <span class=\"token number\">0</span> disk\n└─sda1      <span class=\"token number\">8</span>:1    <span class=\"token number\">0</span>    10G  <span class=\"token number\">0</span> part /mnt\n<span class=\"token punctuation\">..</span>.\n</code></pre>\n<p>Видим что примонтирован диск sda с одним разделом sda1.\nДля нашего образа диска нам нужно как-то подключить файл образа как устройство.</p>\n<p>Один из способов - команда <code>losetup</code>, с помощью нее можно подключать образы как блочные устройства.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> losetup <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">--find</span> <span class=\"token punctuation\">\\</span>      <span class=\"token comment\"># ищет свободный id для блочного устройства</span>\n    <span class=\"token parameter variable\">--partscan</span> <span class=\"token punctuation\">\\</span>  <span class=\"token comment\"># ищет на устройстве разделы, а нас как раз один раздел</span>\n    ./mbr_hdd.img\n\n$ lsblk\n\n<span class=\"token punctuation\">..</span>.\nloop0       <span class=\"token number\">7</span>:0    <span class=\"token number\">0</span>  256M  <span class=\"token number\">0</span> loop <span class=\"token comment\"># видим наш диск с одним разделом</span>\n└─loop0p1 <span class=\"token number\">259</span>:0    <span class=\"token number\">0</span>  255M  <span class=\"token number\">0</span> loop\n<span class=\"token punctuation\">..</span>.\n</code></pre>\n<p>Теперь можем форматировать раздел в ext4:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> mkfs.ext4 /dev/loop0p1\n\n<span class=\"token function\">mke2fs</span> <span class=\"token number\">1.42</span>.13 <span class=\"token punctuation\">(</span><span class=\"token number\">17</span>-May-2015<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">..</span>.\nWriting superblocks and filesystem accounting information: <span class=\"token keyword\">done</span>\n</code></pre>\n<p>Примонтируем раздел и посмотрим что на нем есть.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">mkdir</span> /mnt/hdd               <span class=\"token comment\"># создаем точку монтирования</span>\n\n$ <span class=\"token function\">mount</span> /dev/loop0p1 /mnt/hdd  <span class=\"token comment\"># монтируем раздел</span>\n\n$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> /mnt/hdd               <span class=\"token comment\"># внутри только lost+found</span>\n\ntotal <span class=\"token number\">12</span>\ndrwx------ <span class=\"token number\">2</span> root root <span class=\"token number\">12288</span> May <span class=\"token number\">13</span> <span class=\"token number\">16</span>:45 lost+found\n</code></pre>\n<p>Вот мы плавно и подошли к установке загрузчика - как говорил ранее, будем ставить grub.</p>\n<p>При установке загрузчик будет записывать файлы непосредственно в файловую систему и изменять MBR на самом диске.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> grub-install <span class=\"token punctuation\">\\</span>\n    --root-directory<span class=\"token operator\">=</span>/mnt/hdd <span class=\"token punctuation\">\\</span>  <span class=\"token comment\"># тут нужно указывать полный путь до примонтированного раздела</span>\n     /dev/loop0                  <span class=\"token comment\"># тут указываем сам диск, а не раздел</span>\n\nInstalling <span class=\"token keyword\">for</span> i386-pc platform.\nInstallation finished. No error reported.</code></pre>\n<p>На диске появилась директория <code>boot</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> /mnt/hdd/boot/grub/\ntotal <span class=\"token number\">12</span>\ndrwxr-xr-x <span class=\"token number\">2</span> root root <span class=\"token number\">1024</span> May <span class=\"token number\">13</span> <span class=\"token number\">16</span>:50 fonts\n-rw-r--r-- <span class=\"token number\">1</span> root root <span class=\"token number\">1024</span> May <span class=\"token number\">13</span> <span class=\"token number\">16</span>:50 grubenv\ndrwxr-xr-x <span class=\"token number\">2</span> root root <span class=\"token number\">9216</span> May <span class=\"token number\">13</span> <span class=\"token number\">16</span>:50 i386-pc\ndrwxr-xr-x <span class=\"token number\">2</span> root root <span class=\"token number\">1024</span> May <span class=\"token number\">13</span> <span class=\"token number\">16</span>:50 locale\n\n<span class=\"token comment\"># а команда file говорит так</span>\n$ <span class=\"token function\">file</span> mbr_hdd.img\nmbr_hdd.img: DOS/MBR boot sector</code></pre>\n<p>Загрузчик установлен, пробуем загружаться в QEMU</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ qemu-system-x86_64 <span class=\"token parameter variable\">-nographic</span> <span class=\"token parameter variable\">-m</span> 128m <span class=\"token parameter variable\">-boot</span> c <span class=\"token parameter variable\">-hda</span> ./mbr_hdd.img\n\n<span class=\"token punctuation\">..</span>.\n\nBooting from Hard Disk<span class=\"token punctuation\">..</span>.\n\n                             GNU GRUB  version <span class=\"token number\">2.02</span>\n\n   Minimal <span class=\"token environment constant\">BASH</span>-like line editing is supported. For the first word, TAB\n   lists possible <span class=\"token builtin class-name\">command</span> completions. Anywhere <span class=\"token keyword\">else</span> TAB lists possible\n   device or <span class=\"token function\">file</span> completions.\n\n\ngrub<span class=\"token operator\">></span>\n</code></pre>\n<p>Видим приветствие GRUB и grub shell.</p>\n<p>В шелле можно посмотреть диски, информацию по разделам, поставить классные картинки на boot-screen, но то что нам пригодится сейчас - это возможность указать путь до образа ядра и ram-диска.</p>\n<h3 id=\"zagruzka-yadra\" tabindex=\"-1\">Загрузка ядра <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#zagruzka-yadra\" aria-hidden=\"true\">#</a></h3>\n<p>самый простой вариант получить образ ядра это скопировать его уже из готовой системы</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> /boot\ntotal <span class=\"token number\">31584</span>\n-rw-r--r-- <span class=\"token number\">1</span> root root   <span class=\"token number\">217458</span> Apr <span class=\"token number\">22</span> <span class=\"token number\">18</span>:31 config-4.15.0-99-generic\ndrwxr-xr-x <span class=\"token number\">5</span> root root     <span class=\"token number\">4096</span> May <span class=\"token number\">11</span> <span class=\"token number\">15</span>:58 grub\n-rw-r--r-- <span class=\"token number\">1</span> root root <span class=\"token number\">19659681</span> May <span class=\"token number\">11</span> <span class=\"token number\">15</span>:57 initrd.img-4.15.0-99-generic\n-rw------- <span class=\"token number\">1</span> root root  <span class=\"token number\">4071696</span> Apr <span class=\"token number\">22</span> <span class=\"token number\">18</span>:31 System.map-4.15.0-99-generic\n-rw------- <span class=\"token number\">1</span> root root  <span class=\"token number\">8380056</span> Apr <span class=\"token number\">22</span> <span class=\"token number\">18</span>:32 vmlinuz-4.15.0-99-generic\n\n$ <span class=\"token function\">cp</span> /boot/vmlinuz-4.15.0-99-generic /mnt/hdd/boot</code></pre>\n<p>Запускаем QEMU и в консоли grub грузим ядро:</p>\n<div class=\"info\" style=\"margin-bottom: 15px\">\n<p>тут поменял -nographic на -curses, так лучше отображается в консоли, но этот ключ можно вообще убрать и работать в отдельном окне.</p>\n</div>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ qemu-system-x86_64 <span class=\"token parameter variable\">-curses</span> <span class=\"token parameter variable\">-m</span> 128m <span class=\"token parameter variable\">-boot</span> c <span class=\"token parameter variable\">-hda</span> ./mbr_hdd.img\n\ngrub<span class=\"token operator\">></span> <span class=\"token function\">ls</span> /boot\ngrub/ vmlinuz-4.15.0-99-generic                  <span class=\"token comment\"># вот ядро в директории /boot</span>\n\ngrub<span class=\"token operator\">></span> linux /boot/vmlinuz-4.15.0-99-generic      <span class=\"token comment\"># указываем какое ядро загружать</span>\ngrub<span class=\"token operator\">></span> boot                                       <span class=\"token comment\"># загружаемся</span>\n\n<span class=\"token punctuation\">..</span>.                                              <span class=\"token comment\"># тут лог загрузки</span>\n\n<span class=\"token comment\"># и в итоге получаем ошибку kernel panic</span>\n\n<span class=\"token punctuation\">[</span>    <span class=\"token number\">2.159628</span><span class=\"token punctuation\">]</span> ---<span class=\"token punctuation\">[</span> end Kernel panic - not syncing: VFS: Unable to <span class=\"token function\">mount</span> root fs  on unknown-block<span class=\"token punctuation\">(</span><span class=\"token number\">0,0</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<div class=\"message\">\n<p>В этом режиме чтобы выйти из виртуалки нужно перейти в QEMU monitor по <code>Ctrl-Alt-2</code> и выполнить команду <code>quit</code>. Подробнее про хоткеи в <a href=\"https://qemu.weilnetz.de/doc/qemu-doc.html\" target=\"_blank\" rel=\"noopener\">доке</a> раздел “2.4 Keys in the graphical frontends”</p>\n</div>\n<p>После загрузки ядро должно иметь временную файловую систему и из нее запустить первый процесс в пользовательском пространстве с pid=1.</p>\n<p>Временная файловая система (ram-диск) это и есть initrd и этот образ нужно будет собрать.</p>\n<p>После загрузки ядра при запуске пользовательского пространства нужны хоть какие-то команды и есть такой набор инструментов - busybox.</p>\n<p>busybox - это один бинарный файл, который содержит в себе минимальный набор программ для работы с системой. Добавим busybox в сборке ram-диска.</p>\n<h3 id=\"minimalnyj-initrd\" tabindex=\"-1\">минимальный initrd <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#minimalnyj-initrd\" aria-hidden=\"true\">#</a></h3>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> initrd\n<span class=\"token builtin class-name\">cd</span> initrd\n\n<span class=\"token comment\"># создаем основные директории</span>\n<span class=\"token function\">mkdir</span> bin sys dev proc\n\n<span class=\"token comment\">#  загружаем busybox и расставляем симлинки</span>\n<span class=\"token function\">wget</span> https://busybox.net/downloads/binaries/1.30.0-i686/busybox <span class=\"token parameter variable\">-O</span> bin/busybox\n\n<span class=\"token comment\"># обязательно нужно добавить права на выполнение для busybox</span>\n<span class=\"token function\">chmod</span> +x bin/busybox\n\n<span class=\"token comment\"># симлинки для некоторых команд, остальные добавим позже</span>\n<span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> busybox bin/echo\n<span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> busybox bin/ash\n<span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> busybox bin/ls\n<span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> busybox bin/cat\n\n<span class=\"token comment\"># копируем файлы устройств, про файлы в linux поговорим в других статьях</span>\n<span class=\"token function\">cp</span> <span class=\"token parameter variable\">-a</span> /dev/console ./dev\n<span class=\"token function\">cp</span> <span class=\"token parameter variable\">-a</span> /dev/null ./dev\n<span class=\"token function\">cp</span> <span class=\"token parameter variable\">-a</span> /dev/tty1 ./dev\n<span class=\"token function\">cp</span> <span class=\"token parameter variable\">-a</span> /dev/tty2 ./dev\n\n<span class=\"token comment\"># создаем скрипт с которого начнется запуск пользовательского пространства</span>\n\n<span class=\"token function\">cat</span> <span class=\"token operator\">>></span> ./init <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOF\n#!/bin/ash\n/bin/ash --login\nEOF</span>\n\n<span class=\"token comment\"># делаем скрипт исполняемым</span>\n<span class=\"token function\">chmod</span> +x init\n\n<span class=\"token comment\"># из этой же директории пакуем initrd в cpio-архив</span>\n<span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token operator\">|</span> cpio <span class=\"token parameter variable\">-o</span> <span class=\"token parameter variable\">-H</span> newc <span class=\"token operator\">|</span> <span class=\"token function\">gzip</span> <span class=\"token parameter variable\">-9</span> <span class=\"token operator\">></span> <span class=\"token punctuation\">..</span>/initrd.img\n</code></pre>\n<p>копируем полученный initrd.img в /boot на нашем hdd</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">..</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">cp</span> ./initrd.img /mnt/hdd/boot</code></pre>\n<p>и запускаем qemu:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">$ qemu-system-x86_64 <span class=\"token parameter variable\">-curses</span> <span class=\"token parameter variable\">-m</span> 128m <span class=\"token parameter variable\">-boot</span> c <span class=\"token parameter variable\">-hda</span> ./mbr_hdd.img\n\ngrub<span class=\"token operator\">></span> <span class=\"token function\">ls</span> /boot\ngrub/ vmlinuz-4.15.0-99-generic initrd.img\n\ngrub<span class=\"token operator\">></span> linux /boot/vmlinuz-4.15.0-99-generic    <span class=\"token comment\"># задаем ядро</span>\ngrub<span class=\"token operator\">></span> initrd /boot/initrd.img                  <span class=\"token comment\"># задаем образ initrd</span>\n\ngrub<span class=\"token operator\">></span> boot                                     <span class=\"token comment\"># грузимся</span>\n\n<span class=\"token punctuation\">..</span>.\n\n/ <span class=\"token comment\"># ls</span>\n\n bin   dev   init  proc  root  sbin  sys</code></pre>\n<p>Видим процесс загрузки ядра, после загрузки видим шелл, выполняем <code>ls</code> и видим содержимое диска - самый минимум грузится осталось немного автоматизировать процесс загрузки.</p>\n<p>Настроим grub чтобы система стартовала без ручного ввода ядра и ram-диска.</p>\n<p>Для этого достаточно в <code>/boot/grub</code> создать файл <code>grub.cfg</code> (для grub2 нужно именно расширение <code>.cfg</code>, а не <code>.conf</code>)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">set</span> <span class=\"token assign-left variable\">default</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n<span class=\"token builtin class-name\">set</span> <span class=\"token assign-left variable\">timeout</span><span class=\"token operator\">=</span><span class=\"token number\">5</span>\n\nmenuentry <span class=\"token string\">'linux'</span> <span class=\"token punctuation\">{</span>\n  linux /boot/vmlinuz-4.15.0-99-generic\n  initrd /boot/initrd.img\n<span class=\"token punctuation\">}</span></code></pre>\n<p>если снова запустить qemu - увидим меню выбора системы</p>\n<p><picture><source type=\"image/webp\" srcset=\"https://rootaround.github.io/assets/img/We2UeWCtDI-640.webp 640w, https://rootaround.github.io/assets/img/We2UeWCtDI-768.webp 768w, https://rootaround.github.io/assets/img/We2UeWCtDI-1280.webp 1280w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><source type=\"image/jpeg\" srcset=\"https://rootaround.github.io/assets/img/We2UeWCtDI-640.jpeg 640w, https://rootaround.github.io/assets/img/We2UeWCtDI-768.jpeg 768w, https://rootaround.github.io/assets/img/We2UeWCtDI-1280.jpeg 1280w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><source type=\"image/png\" srcset=\"https://rootaround.github.io/assets/img/We2UeWCtDI-640.png 640w, https://rootaround.github.io/assets/img/We2UeWCtDI-768.png 768w, https://rootaround.github.io/assets/img/We2UeWCtDI-1280.png 1280w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><img alt=\"\" loading=\"lazy\" decoding=\"async\" src=\"https://rootaround.github.io/assets/img/We2UeWCtDI-640.jpeg\" width=\"1280\" height=\"892\" /></picture></p>\n<p>потом загрузку ядра и шелл</p>\n<p><picture><source type=\"image/webp\" srcset=\"https://rootaround.github.io/assets/img/W_PXiu_U7h-640.webp 640w, https://rootaround.github.io/assets/img/W_PXiu_U7h-768.webp 768w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><source type=\"image/jpeg\" srcset=\"https://rootaround.github.io/assets/img/W_PXiu_U7h-640.jpeg 640w, https://rootaround.github.io/assets/img/W_PXiu_U7h-768.jpeg 768w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><source type=\"image/png\" srcset=\"https://rootaround.github.io/assets/img/W_PXiu_U7h-640.png 640w, https://rootaround.github.io/assets/img/W_PXiu_U7h-768.png 768w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><img alt=\"\" loading=\"lazy\" decoding=\"async\" src=\"https://rootaround.github.io/assets/img/W_PXiu_U7h-640.jpeg\" width=\"768\" height=\"570\" /></picture></p>\n<h2 id=\"itogo\" tabindex=\"-1\">Итого <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#itogo\" aria-hidden=\"true\">#</a></h2>\n<p>В общих чертах разобрались с процессом загрузки и создали образ, в котором загружается ядро и первым процессом стартует shell (ash). Это только начало, дальше будем разбираться с файловой системой и с тем процесс должен быть запущен первым, да и вообще с процессами и не только.</p>\n<h2 id=\"primery\" tabindex=\"-1\">Примеры <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#primery\" aria-hidden=\"true\">#</a></h2>\n<p>Готовый образ из статьи можно взять тут:</p>\n<p><a href=\"https://github.com/rootaround/examples/tree/master/linux-first/2020-05-13-boot-mbr\" target=\"_blank\" rel=\"noopener\">https://github.com/rootaround/examples/tree/master/linux-first/2020-05-13-boot-mbr</a></p>\n<h2 id=\"ssylki\" tabindex=\"-1\">Ссылки <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-boot-mbr/#ssylki\" aria-hidden=\"true\">#</a></h2>\n<ul>\n<li>Про BIOS: <a href=\"https://ru.wikipedia.org/wiki/BIOS\" target=\"_blank\" rel=\"noopener\">https://ru.wikipedia.org/wiki/BIOS</a></li>\n<li>Про стандарты таблиц разделов MBR, GPT <a href=\"https://losst.ru/chem-otlichaetsya-mbr-ot-gpt\" target=\"_blank\" rel=\"noopener\">https://losst.ru/chem-otlichaetsya-mbr-ot-gpt</a></li>\n<li>Форматирование диска: <a href=\"https://losst.ru/formatirovanie-diska-v-linux\" target=\"_blank\" rel=\"noopener\">https://losst.ru/formatirovanie-diska-v-linux</a></li>\n<li>GRUB (wikipedia) <a href=\"https://ru.wikipedia.org/wiki/GNU_GRUB\" target=\"_blank\" rel=\"noopener\">https://ru.wikipedia.org/wiki/GNU_GRUB</a></li>\n<li>GNU GRUB официальная дока <a href=\"https://www.gnu.org/software/grub/manual/grub/grub.html\" target=\"_blank\" rel=\"noopener\">https://www.gnu.org/software/grub/manual/grub/grub.html</a></li>\n<li>IBM: Подробности процесса загрузки Linux <a href=\"https://www.ibm.com/developerworks/ru/library/l-linuxboot/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/ru/library/l-linuxboot/</a></li>\n</ul>\n<!--\nGRUB\n\n- https://superuser.com/questions/130955/how-to-install-grub-into-an-img-file\n- https://ru.wikibooks.org/wiki/Grub_2#%D0%92%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_GRUB2_%D1%81_LiveCD\n- https://www.gnu.org/software/grub/manual/grub/grub.html\n- https://wiki.archlinux.org/index.php/GRUB_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C_GRUB2\n- https://serverfault.com/questions/869559/grub-hangs-before-menu-after-a-hdd-upgrade-how-to-debug\n\n\n\nhttps://www.ibm.com/developerworks/library/l-initrd/\nhttps://www.kernel.org/doc/html/v4.14/admin-guide/initrd.html\nhttps://ru.wikipedia.org/wiki/BusyBox\nhttps://habr.com/post/126427/\n\nhttp://iportnov.blogspot.com/2010/03/linux-10.html\n\nhttps://losst.ru/ustanovka-zagruzchika-grub\nhttps://losst.ru/chem-otlichaetsya-mbr-ot-gpt\n\nhttps://www.ibm.com/developerworks/ru/library/l-linuxboot/\n\nhttps://unix.stackexchange.com/questions/124681/how-to-ssh-from-host-to-guest-using-qemu\n\nhttps://losst.ru/sobiraem-yadro-linux\n\nhttps://ru.wikipedia.org/wiki/Процесс_загрузки_Linux\n\nhttps://losst.ru/ustanovka-zagruzchika-grub\n\nhttps://losst.ru/nastrojka-zagruzchika-grub\n\nhttps://wiki.archlinux.org/index.php/GRUB_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C_GRUB2\n\n-->\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-first\">Все статьи серии “Linux First”</a></p>\n",
      "date_published": "2020-05-15T00:00:00Z"
    },{
      "id": "https://rootaround.github.io/linux-first-shortly-about-kernel/",
      "url": "https://rootaround.github.io/linux-first-shortly-about-kernel/",
      "title": "Linux First: Кратко о linux-ядре",
      "content_html": "<p>Этим постом начинаю серию статей “Linux First” - разбираюсь как устроен и как работает linux с начала загрузки ядра и дальше про подсистемы, сеть, процессы и многое другое.</p>\n<p>Cписок статей серии можно найти по тэгу <a href=\"https://rootaround.github.io/tags/linux-first\">linux-first</a></p>\n<p>Сегодня немного про историю и в общем про архитектуру.</p>\n<h3 id=\"istoriya\" tabindex=\"-1\">История <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-shortly-about-kernel/#istoriya\" aria-hidden=\"true\">#</a></h3>\n<p>В августе 1991 года Линус Торвальдс написал в новостную ленту “minix” <a href=\"https://groups.google.com/forum/#!msg/comp.os.minix/dlNtH7RRrGA/SwRavCzVE7gJ\" target=\"_blank\" rel=\"noopener\">сообщение</a> о том что он разрабатывает свободную операционую систему и хочет получить фидбэк от заинтересованных людей.</p>\n<p>В сентябре Линус опубликовал версию 0.01. Этот исторический код можно посмотреть на <a href=\"https://github.com/zavg/linux-0.01\" target=\"_blank\" rel=\"noopener\">github</a>.</p>\n<p><a href=\"http://www.oldlinux.org/\" target=\"_blank\" rel=\"noopener\">Особо сентиментальные ребята</a> запилили образы для Qemu, в которых запускаются первые версии ядра и можно даже вызывать “доисторические” команды ls без хэлпов и прочих прелестей современных unix-команд.</p>\n<p>К проекту сразу появился интерес и совместными усилиями Линуса и коммьюнити linux-ядро начало развиваться.</p>\n<p>Через 3 года в 1994 выходит <a href=\"https://github.com/kalamangga-net/linux-1.0\" target=\"_blank\" rel=\"noopener\">первая версия</a>.</p>\n<p>Ядро изначально проектировалось как монолитное и переносимое на разные процессорные архитектуры.\nСобственно из-за аритектуры в 1992 в группе обсуждения minix разгорелся холивар “монолит-ядро vs микро-ядрo” между Линусом Торвальдсом и Эндрю Таненбаумом (<em>почти как и сейчас про монолит vs микросервисы</em>).</p>\n<!-- ОС Minix была разработана Эндрю Таненбаумом для образовательных целей, чтобы его студенты могли  поэкспериментировать с операционной системой. -->\n<p>Основной посыл холивара был в том что монолитное ядро устарело уже в 1992 году, а микроядра рулят и за ними будущее, но как показала история, даже 26 лет спустя монолитное ядро все еще живо и продолжает развиваться.</p>\n<p>Текущая версия доросла до <code>5.6</code> (май 2020) и код начиная с <code>2.6</code> можно смотреть на <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/refs/\" target=\"_blank\" rel=\"noopener\">оф сайте</a> или на github-зеркале <a href=\"https://github.com/torvalds/linux\" target=\"_blank\" rel=\"noopener\">torvalds/linux</a></p>\n<h3 id=\"arhitektura\" tabindex=\"-1\">Архитектура <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-shortly-about-kernel/#arhitektura\" aria-hidden=\"true\">#</a></h3>\n<p><picture><source type=\"image/webp\" srcset=\"https://rootaround.github.io/assets/img/WWqz2PWZIQ-410.webp 410w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><source type=\"image/png\" srcset=\"https://rootaround.github.io/assets/img/WWqz2PWZIQ-410.png 410w\" sizes=\"(max-width: 768px) 100vw, 768px\" /><img alt=\"Cхема из статьи IBM &quot;Анатомия ядра Linux&quot;\" loading=\"lazy\" decoding=\"async\" src=\"https://rootaround.github.io/assets/img/WWqz2PWZIQ-410.jpeg\" width=\"410\" height=\"250\" /></picture></p>\n<p>Ядро делится на пространство ядра и пространство пользователя.</p>\n<p>Пространство ядра через Интерфейс системных вызовов (SCI) позволяется вызывать функции ядра из пространства пользователя.</p>\n<p>Вся работа с железом контролируется ядром, основная часть ядра архитектурно-независима, то есть этот код работает на любой архитектуре процессоров.</p>\n<p>Специфичный код для работы с железом - архитектуро-зависимый - и либо уже есть в дистрибутиве Linux для определенной архитектуры, либо добавляется с помощью драйверов.</p>\n<p>Ресурсы <strong>CPU</strong> распределяются между процессами планировщиком процессов O(1). Код планировщика может использовать фишки определенной процессорной архитектуры, поэтому как раз код планировщика разделен на архитектурно-независимый и архитектурно-зависимый.</p>\n<p><strong>Память</strong> аналогично ресурсам CPU контролируется ядром и эта же подсистема управляет подкачкой (swap).</p>\n<p><strong>Виртуальная файловая система (VFS)</strong> абстрагирует от конкретных файловых систем и через SCI позволяет работать с любыми файловыми система одинаково. Поддержка конкретных файлов систем добавляется через модули ядра.</p>\n<p><strong>Сеть</strong> контролируется отдельной подсистемой и через все тот же SCI позволяет открывать и работать с сетевыми сокетами разных протоколов.</p>\n<p>Если хочется узнать подробнее про подсистемы - есть целая интерактивная карта linux-ядра, из которой можно узнать много нового и интересного - <a href=\"http://www.makelinux.net/kernel_map/\" target=\"_blank\" rel=\"noopener\"><strong>www.makelinux.net/kernel_map</strong></a></p>\n<p>Ну и документацию конечно никто не отменял <a href=\"https://www.kernel.org/doc/html/latest/\" target=\"_blank\" rel=\"noopener\"><strong>www.kernel.org/doc/html/latest/</strong></a></p>\n<h3 id=\"istochniki\" tabindex=\"-1\">Источники <a class=\"direct-link\" href=\"https://rootaround.github.io/linux-first-shortly-about-kernel/#istochniki\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>Схема архитектуры и описание из статьи IBM “<a href=\"https://www.ibm.com/developerworks/ru/library/l-linux-kernel/\" target=\"_blank\" rel=\"noopener\">Анатомия ядра Linux</a>”. В статье чуть подробнее описано как устроено ядро.</li>\n</ul>\n<hr />\n<p><a href=\"https://rootaround.github.io/tags/linux-first\">Все статьи серии “Linux First”</a></p>\n",
      "date_published": "2020-05-13T01:00:00Z"
    }
  ]
}
